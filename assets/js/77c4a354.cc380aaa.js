"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[35415],{12818:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/flatten_advanced_settings-5e7381dda09858272e7d1b0c1f5c9d60.png"},28453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var s=n(96540);const a={},i=s.createContext(a);function l(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(i.Provider,{value:t},e.children)}},41848:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/flatten_output_interim-cf9c2a3d1f4c7528791c2a7243b0aee6.png"},51960:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/flatten_input-6f94e353ebd52d670b50729aecc0dbb1.png"},52965:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/flatten_gem-088dcb90a9e1679a18b6f2497692a93b.png"},55547:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"SQL/gems/transform/flattenschema","title":"Flatten Schema","description":"Flatten nested data","source":"@site/docs/SQL/gems/transform/flattenschema.md","sourceDirName":"SQL/gems/transform","slug":"/SQL/gems/transform/flattenschema","permalink":"/SQL/gems/transform/flattenschema","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"gems","permalink":"/tags/gems"},{"inline":true,"label":"schema","permalink":"/tags/schema"},{"inline":true,"label":"explode","permalink":"/tags/explode"},{"inline":true,"label":"flatten","permalink":"/tags/flatten"}],"version":"current","frontMatter":{"title":"Flatten Schema","id":"flattenschema","description":"Flatten nested data","tags":["gems","schema","explode","flatten"]},"sidebar":"mySidebar","previous":{"title":"Filter","permalink":"/SQL/gems/transform/filter"},"next":{"title":"Limit","permalink":"/SQL/gems/transform/limit"}}');var a=n(74848),i=n(28453);const l={title:"Flatten Schema",id:"flattenschema",description:"Flatten nested data",tags:["gems","schema","explode","flatten"]},o=void 0,d={},c=[{value:"The Input",id:"the-input",level:2},{value:"The Expressions",id:"the-expressions",level:2},{value:"The Output",id:"the-output",level:2},{value:"Advanced settings",id:"advanced-settings",level:2}];function r(e){const t={admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("h3",{children:(0,a.jsx)("span",{class:"badge",children:"SQL Gem"})}),"\n",(0,a.jsxs)(t.p,{children:["When processing raw data it can be useful to flatten complex data types like ",(0,a.jsx)(t.code,{children:"Struct"}),"s and ",(0,a.jsx)(t.code,{children:"Array"}),"s into simpler, flatter schemas. This allows you to preserve all schemas, and not just the first one. You can use FlattenSchema with Snowflake models."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"The FlattenSchema gem",src:n(52965).A+"",width:"290",height:"305"})}),"\n",(0,a.jsx)(t.h2,{id:"the-input",children:"The Input"}),"\n",(0,a.jsx)(t.p,{children:"FlattenSchema works on Snowflake sources that have nested columns that you'd like to extract into a flat schema."}),"\n",(0,a.jsx)(t.p,{children:"For example, with an input schema like so:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Input schema",src:n(51960).A+"",width:"1310",height:"754"})}),"\n",(0,a.jsx)(t.p,{children:"And the data looks like so:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Input data",src:n(64221).A+"",width:"2620",height:"1537"})}),"\n",(0,a.jsxs)(t.p,{children:["We want to extract the ",(0,a.jsx)(t.code,{children:"contact"}),", and all of the columns from the ",(0,a.jsx)(t.code,{children:"struct"}),"s in ",(0,a.jsx)(t.code,{children:"content"})," into a flattened schema."]}),"\n",(0,a.jsx)(t.h2,{id:"the-expressions",children:"The Expressions"}),"\n",(0,a.jsxs)(t.p,{children:["Having added a ",(0,a.jsx)(t.code,{children:"FlattenSchema"})," gem to your model, all you need to do is click the column names you wish to extract and they'll be added to the ",(0,a.jsx)(t.code,{children:"Expressions"})," section."]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:"You can click to add all columns, which would make all nested leaf level values of an object visible as columns."})}),"\n",(0,a.jsxs)(t.p,{children:["Once added you can change the ",(0,a.jsx)(t.code,{children:"Output Column"})," for a given row to change the name of the Column in the output."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Adding expressions",src:n(73533).A+"",width:"2620",height:"1507"})}),"\n",(0,a.jsx)(t.h2,{id:"the-output",children:"The Output"}),"\n",(0,a.jsxs)(t.p,{children:["If we check the ",(0,a.jsx)(t.code,{children:"Output"})," tab in the gem, you'll see the schema that we've created using the selected columns."]}),"\n",(0,a.jsx)(t.p,{children:"And here's what the output data looks like:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Output interim",src:n(41848).A+"",width:"2620",height:"1507"})}),"\n",(0,a.jsx)(t.p,{children:"The nested contact information has been flatten so that you have individual rows for each content type."}),"\n",(0,a.jsx)(t.h2,{id:"advanced-settings",children:"Advanced settings"}),"\n",(0,a.jsxs)(t.p,{children:["If you're familiar with Snowflake's ",(0,a.jsx)(t.code,{children:"FLATTEN"})," table function, you can use the advanced settings to customize the optional column arguments."]}),"\n",(0,a.jsx)(t.p,{children:"To use the advanced settings, hover over a column, and click the dropdown arrow."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Advanced settings",src:n(12818).A+"",width:"2620",height:"1507"})}),"\n",(0,a.jsx)(t.p,{children:"You can customize the following options:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Path to the element: The path to the element within the variant data structure that you want to flatten."}),"\n",(0,a.jsxs)(t.li,{children:["Flatten all elements recursively: If set to ",(0,a.jsx)(t.code,{children:"false"}),", only the element mentioned in the path is expanded. If set to ",(0,a.jsx)(t.code,{children:"true"}),", all sub-elements are expanded recursively. This is set to false by default."]}),"\n",(0,a.jsxs)(t.li,{children:["Preserve rows with missing fields: If set to ",(0,a.jsx)(t.code,{children:"false"}),", rows with missing fields are omitted from the output. If set to ",(0,a.jsx)(t.code,{children:"true"}),", rows with missing fields are generated with ",(0,a.jsx)(t.code,{children:"null"})," in the key, index, and value columns. This is set to false by default."]}),"\n",(0,a.jsxs)(t.li,{children:["Datatype that needs to be flattened: The data type that you want to flatten. You can choose ",(0,a.jsx)(t.code,{children:"Object"}),", ",(0,a.jsx)(t.code,{children:"Array"}),", or ",(0,a.jsx)(t.code,{children:"Both"}),". This is set to ",(0,a.jsx)(t.code,{children:"Both"})," by default."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}},64221:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/flatten_input_interim-32f3884d132f1fba87579a634b4bf47d.png"},73533:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/flatten_add_exp-e1b9e410e33edebaf180b873544b1152.png"}}]);