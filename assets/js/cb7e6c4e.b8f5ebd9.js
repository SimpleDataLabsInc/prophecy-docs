"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[15280],{687:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/NumberBox-1fe504d50489ab3df070649f02f3fd9a.png"},1898:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/SelectBox-dcc91bace7e0c68f1182ae83caacce4b.png"},8191:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/TextArea-6db0b051016afc1452d04c2917931407.png"},18754:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/ExpTable-59da0754e0c5d684e1579a97c2067ed6.png"},19819:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/BasicTable-dbc832ff342cd71da35dc034d2f5997f.png"},23018:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/SchemaTable-4e0f14fa1d938481d89fec561f3133aa.png"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(96540);const l={},s=r.createContext(l);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},28923:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/TitleElement-e690c090cf1577b1be9fc7a59ea99f04.png"},41042:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"extensibility/gem-builder/gem-builder-ui","title":"Build Gem UI","description":"Build the UI of your custom gem using uispec.py classes","source":"@site/docs/extensibility/gem-builder/gem-builder-ui.md","sourceDirName":"extensibility/gem-builder","slug":"/engineers/gem-builder-ui","permalink":"/engineers/gem-builder-ui","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"gem builder","permalink":"/tags/gem-builder"}],"version":"current","frontMatter":{"title":"Build Gem UI","id":"gem-builder-ui","slug":"/engineers/gem-builder-ui","description":"Build the UI of your custom gem using uispec.py classes","tags":["gem builder"]},"sidebar":"mySidebar","previous":{"title":"Reference for Spark","permalink":"/engineers/gem-builder-reference"},"next":{"title":"Optimization functions","permalink":"/engineers/optimization-functions"}}');var l=t(74848),s=t(28453);const o={title:"Build Gem UI",id:"gem-builder-ui",slug:"/engineers/gem-builder-ui",description:"Build the UI of your custom gem using uispec.py classes",tags:["gem builder"]},i=void 0,p={},a=[{value:"Atoms",id:"atoms",level:2},{value:"Checkbox",id:"checkbox",level:3},{value:"Switch",id:"switch",level:3},{value:"TextBox",id:"textbox",level:3},{value:"ExpressionBox",id:"expressionbox",level:3},{value:"ExpTable",id:"exptable",level:3},{value:"BasicTable",id:"basictable",level:3},{value:"TitleElement",id:"titleelement",level:3},{value:"TextArea",id:"textarea",level:3},{value:"SchemaTable",id:"schematable",level:3},{value:"Ports",id:"ports",level:3},{value:"SchemaColumnsDropdown",id:"schemacolumnsdropdown",level:3},{value:"SelectBox",id:"selectbox",level:3},{value:"AlertBox",id:"alertbox",level:3},{value:"NumberBox",id:"numberbox",level:3},{value:"Markdown",id:"markdown",level:3},{value:"RadioGroup",id:"radiogroup",level:3},{value:"Editor",id:"editor",level:3},{value:"Layout",id:"layout",level:2},{value:"StackLayout",id:"stacklayout",level:3},{value:"ColumnLayout",id:"columnlayout",level:3},{value:"FieldPicker",id:"fieldpicker",level:3},{value:"Explore <code>uispec.py</code>",id:"explore-uispecpy",level:2}];function f(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.p,{children:["In Prophecy, the ",(0,l.jsx)(n.code,{children:"dialog()"})," function defines the visual configuration interface for your gem. This is what users see and interact with when setting up or editing a gem in the UI."]}),"\n",(0,l.jsxs)(n.p,{children:["To build an effective dialog, you'll use layout containers, UI controls (like checkboxes, text boxes, expression editors), and bindings to connect UI elements to your gem's configuration. All of these elements are imported into your custom gem from ",(0,l.jsx)(n.code,{children:"uispec.py"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["By examining ",(0,l.jsx)(n.code,{children:"uispec.py"}),", you can:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Discover the full library of UI elements."}),"\n",(0,l.jsx)(n.li,{children:"Understand what each component does and what methods it supports."}),"\n",(0,l.jsx)(n.li,{children:"See how to configure visual behavior, bind properties, add hints/tooltips, and more."}),"\n"]}),"\n",(0,l.jsx)(n.admonition,{type:"info",children:(0,l.jsxs)(n.p,{children:["To see an example ",(0,l.jsx)(n.code,{children:"dialog()"})," function, visit ",(0,l.jsx)(n.a,{href:"/engineers/gem-builder-reference#dialog-ui",children:"Gem Builder reference"}),"."]})}),"\n",(0,l.jsx)(n.admonition,{type:"tip",children:(0,l.jsxs)(n.p,{children:["To reference the complete code of a certain gem, search for the gem using the left sidebar of the project editor. Click the gem to open its code, then look for the ",(0,l.jsx)(n.code,{children:"dialog()"})," function. This function contains the code that determines how UI components are configured."]})}),"\n",(0,l.jsx)(n.h2,{id:"atoms",children:"Atoms"}),"\n",(0,l.jsxs)(n.p,{children:["Atoms are basic UI components defined in ",(0,l.jsx)(n.code,{children:"uispec.py"})," that you can use in the gem dialog configuration. Below are the most commonly used atoms, with example code and images for reference."]}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"checkbox",children:"Checkbox"}),"\n",(0,l.jsx)(n.p,{children:"Boolean checkbox element that a user can select or unselect."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'Checkbox("First row is header")\n'})}),"\n",(0,l.jsx)("img",{src:t(95218).A,alt:"Checkbox",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"switch",children:"Switch"}),"\n",(0,l.jsx)(n.p,{children:"Boolean toggle that a user can enable or disable."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'Switch("")\n'})}),"\n",(0,l.jsx)("img",{src:t(45553).A,alt:"Switch",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"textbox",children:"TextBox"}),"\n",(0,l.jsx)(n.p,{children:"Allows the user to type a single line of input."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'TextBox("Column delimiter")\n'})}),"\n",(0,l.jsx)("img",{src:t(54029).A,alt:"TextBox",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"expressionbox",children:"ExpressionBox"}),"\n",(0,l.jsx)(n.p,{children:"Input for code expressions."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'ExpressionBox("Pivot Column")\n    .makeFieldOptional()\n    .withSchemaSuggestions()\n    .bindPlaceholders(\n    {{\n        "scala": "col(\\"col_name\\")",\n        "python": "col(\\"col_name\\")",\n        "sql": "col_name"\n    }}\n    )\n    .bindProperty("pivotColumn")\n'})}),"\n",(0,l.jsx)("img",{src:t(96676).A,alt:"ExpressionBox",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"exptable",children:"ExpTable"}),"\n",(0,l.jsx)(n.p,{children:"Dynamic table with target and expression columns."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'ExpTable("Aggregate Expressions").bindProperty("aggregate").withCopilotEnabledExpressions().allowCopilotExpressionsFix()\n'})}),"\n",(0,l.jsx)("img",{src:t(18754).A,alt:"ExpTable",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"basictable",children:"BasicTable"}),"\n",(0,l.jsx)(n.p,{children:"Configurable table with editable cells and optional footers."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'BasicTable(\n    "Unique Values",\n    height="400px",\n    columns=[\n        Column(\n            "Unique Values",\n            "colName",\n            (\n                TextBox("").bindPlaceholder(\n                    "Enter value present in pivot column"\n                )\n            ),\n        )\n    ],\n).bindProperty("pivotValues")\n'})}),"\n",(0,l.jsx)("img",{src:t(19819).A,alt:"BasicTable",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"titleelement",children:"TitleElement"}),"\n",(0,l.jsx)(n.p,{children:"Static heading element, rendered as title text with optional heading level."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'TitleElement("Where Clause")\n'})}),"\n",(0,l.jsx)("img",{src:t(28923).A,alt:"TitleElement",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"textarea",children:"TextArea"}),"\n",(0,l.jsx)(n.p,{children:"Multi-line text input area for longer descriptions."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'TextArea("Description", 2, placeholder="Dataset description...")\n'})}),"\n",(0,l.jsx)("img",{src:t(8191).A,alt:"TextArea",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"schematable",children:"SchemaTable"}),"\n",(0,l.jsx)(n.p,{children:"Information about the dataset schema, including column names, data type, and metadata."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'SchemaTable("").bindProperty("schema")\n'})}),"\n",(0,l.jsx)("img",{src:t(23018).A,alt:"SchemaTable",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"ports",children:"Ports"}),"\n",(0,l.jsx)(n.p,{children:"Component for displaying and editing gem input or output ports."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'Ports(minInputPorts=2,\n    selectedFieldsProperty=("columnsSelector"),\n    singleColumnClickCallback=self.onClickFunc,\n    allColumnsSelectionCallback=self.allColumnsSelectionFunc).editableInput(True)\n'})}),"\n",(0,l.jsx)("img",{src:t(92545).A,alt:"Ports",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"schemacolumnsdropdown",children:"SchemaColumnsDropdown"}),"\n",(0,l.jsx)(n.p,{children:"Dropdown that lets the user select columns defined in the dataset schema."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'SchemaColumnsDropdown("Partition Columns")\n    .withMultipleSelection()\n    .bindSchema("schema")\n    .bindProperty("partitionColumns")\n'})}),"\n",(0,l.jsx)("img",{src:t(85932).A,alt:"SchemaColumnsDropdown",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"selectbox",children:"SelectBox"}),"\n",(0,l.jsx)(n.p,{children:"Dropdown menu with search and other configuration options."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'SelectBox("")\n    .addOption("Inner", "inner")\n    .addOption("Outer", "outer")\n    .addOption("Left Outer", "left_outer")\n    .addOption("Right Outer", "right_outer")\n    .addOption("Left Semi", "left_semi")\n    .addOption("Left Anti", "left_anti")\n    .addOption("Cross Join", "cross")\n'})}),"\n",(0,l.jsx)("img",{src:t(1898).A,alt:"SelectBox",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"alertbox",children:"AlertBox"}),"\n",(0,l.jsx)(n.p,{children:"Message box for alerts/info/warnings."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'AlertBox(\n    variant="success",\n    _children=[\n        Markdown(\n            ...\n        )\n    ]\n)\n'})}),"\n",(0,l.jsx)("img",{src:t(41604).A,alt:"AlertBox",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"numberbox",children:"NumberBox"}),"\n",(0,l.jsx)(n.p,{children:"Allows the user to input an integer. Does not support floats."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'NumberBox("Label for Number Box", placeholder="0")\n'})}),"\n",(0,l.jsx)("img",{src:t(687).A,alt:"AlertBox",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"markdown",children:"Markdown"}),"\n",(0,l.jsx)(n.p,{children:"Displays static Markdown-formatted content."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'Markdown(\n    "**Column Split Delimiter Examples:**"\n    "\\n"\n    "- **Tab-separated values:**"\n    "\\n"\n    "   **Delimiter:** \\\\t"\n    "\\n"\n    "   Example: Value1<tab>Value2<tab>Value3"\n    "\\n"\n    "- **Newline-separated values:**"\n    "\\n"\n    "   **Delimiter:** \\\\n"\n    "\\n"\n    "   Example: Value1\\\\nValue2\\\\nValue3"\n    "\\n"\n    "- **Pipe-separated values:**"\n    "\\n"\n    "   **Delimiter:** |"\n    "\\n"\n    "   Example: Value1|Value2|nValue3"\n)\n'})}),"\n",(0,l.jsx)("img",{src:t(90298).A,alt:"Markdown",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"radiogroup",children:"RadioGroup"}),"\n",(0,l.jsx)(n.p,{children:"A group of radio buttons that can have labels, values, icons, and descriptions."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'RadioGroup("Operation Type")\n    .addOption(\n        "Union",\n        "unionAll",\n        ("UnionAll"),\n        ("Returns a dataset containing rows in any one of the input Datasets, while preserving duplicates.")\n    )\n'})}),"\n",(0,l.jsx)("img",{src:t(47479).A,alt:"Editor",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"editor",children:"Editor"}),"\n",(0,l.jsx)(n.p,{children:"Code editor with expression builder support and schema suggestions."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:'Editor(height=("100%")).withSchemaSuggestions().bindProperty("condition.expression")\n'})}),"\n",(0,l.jsx)("img",{src:t(64438).A,alt:"Editor",width:"75%",style:{border:"1px solid var(--ifm-color-gray-200)",borderRadius:"8px"}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"layout",children:"Layout"}),"\n",(0,l.jsx)(n.p,{children:"The layout components let you organize your gems with columns, tabs, and more."}),"\n",(0,l.jsx)(n.h3,{id:"stacklayout",children:"StackLayout"}),"\n",(0,l.jsx)(n.p,{children:"This arranges its child elements in a vertical stack to place elements one below the other."}),"\n",(0,l.jsx)(n.h3,{id:"columnlayout",children:"ColumnLayout"}),"\n",(0,l.jsx)(n.p,{children:"This component arranges its child elements in horizontal columns, allowing for a side-by-side layout."}),"\n",(0,l.jsx)(n.h3,{id:"fieldpicker",children:"FieldPicker"}),"\n",(0,l.jsx)(n.p,{children:"This is a form-like component that contains labeled input fields. Each field you add call adds a new form control (like text box, checkbox, select box) associated with a specific property."}),"\n",(0,l.jsxs)(n.h2,{id:"explore-uispecpy",children:["Explore ",(0,l.jsx)(n.code,{children:"uispec.py"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",metastring:"showLineNumbers",children:'import copy\nimport enum\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field, replace\nfrom typing import TypeVar, Generic, Optional, List, Any, Dict\nfrom typing import Union\n\nfrom pyspark.sql.column import Column as sparkColumn\nfrom pyspark.sql.functions import col\n\nfrom prophecy.cb.decorator import singleton\nfrom prophecy.cb.util.StringUtils import isBlank\nfrom enum import Enum\n\n\'\'\' ---------------------------- BASE ----------------------------\'\'\'\n\n\n@singleton\nclass UISpec:\n    currentId: int = 0\n\n    def defaultLanguages(self) -> set:\n        return {\'scala\', \'python\', \'sql\'}\n\n    def getId(self) -> int:\n        self.currentId = self.currentId + 1\n        return self.currentId\n\n\n@dataclass(frozen=True)\nclass PropertyContext:\n    contextName: str\n    prefix: str\n\n\ndef propertyPath(property: str) -> str:\n    if property.startswith("$.metadata"):\n        return f"${{{property}}}"\n    elif property.startswith("record."):\n        return f"${{{property}}}"\n    elif not property.startswith("component."):\n        return f\'${{{".".join([prop for prop in ["component", "properties", property] if prop])}}}\'\n    else:\n        return f"${{{property}}}"\n\n\nclass Element(ABC):\n    id: str = f"{UISpec().getId()}"\n\n    def __post_init__(self):\n        self.id = f"{UISpec().getId()}"\n\n    @abstractmethod\n    def kind(self) -> str:\n        pass\n\n    @abstractmethod\n    def json(self) -> dict:\n        pass\n\n    def propertyPath(self, property: str) -> str:\n        return propertyPath(property)\n\n\n\nclass Atom(Element, ABC):\n    @abstractmethod\n    def title(self) -> str:\n        pass\n\n    @abstractmethod\n    def property(self) -> Optional[str]:\n        pass\n\n    @abstractmethod\n    def bindProperty(self, property: str):\n        pass\n\n    def propertyKey(self) -> str:\n        return "value"\n\n    def getTemplateElements(self) -> List[Element]:\n        return []\n\n    def jsonProperties(self) -> dict:\n        return {"title": self.title()}\n\n    def json(self) -> dict:\n        properties = self.jsonProperties()\n        localProperty = self.property()\n        if localProperty is not None:\n            properties[self.propertyKey()] = self.propertyPath(localProperty)\n        return {"id": self.id, "kind": self.kind(), "properties": properties}\n\n\nElementType = TypeVar("ElementType", bound=Element)\n\n\nclass Container(Generic[ElementType], Element, ABC):\n    @abstractmethod\n    def children(self) -> list:\n        pass\n\n    def jsonProperties(self) -> dict:\n        return {}\n\n    def json(self) -> dict:\n        tmpList = []\n        childs = self.children()\n        if childs is not None:\n            reversedChilds = reversed(childs)\n            for child in reversedChilds:\n                tmpList.append(child.json())\n        return {\n            "id": self.id,\n            "kind": self.kind(),\n            "properties": self.jsonProperties(),\n            "contains": tmpList\n        }\n\n\n@enum.unique\nclass CopilotType(enum.Enum):\n    button = "button"\n    prompt = "prompt"\n\n    @staticmethod\n    def get_enum(value):\n        if value == "button":\n            return CopilotType.button\n        elif value == "prompt":\n            return CopilotType.prompt\n\n    def to_json(self):\n        return self.value\n\n@enum.unique\nclass AutoSuggestType(enum.Enum):\n    none = "none"\n    update = "update"\n    placeholder = "placeholder"\n\n    @staticmethod\n    def get_enum(value):\n        if value == "none":\n            return AutoSuggestType.none\n        elif value == "update":\n            return AutoSuggestType.update\n        elif value == "placeholder":\n            return AutoSuggestType.placeholder\n\n    def to_json(self):\n        return self.value\n\n@dataclass\nclass CopilotSpecProps:\n    """\n    The copilot spec props\n    ..........\n    Attributes\n    ----------\n    buttonLabel : str\n        The button label for the copilot button\n    align : str\n        Left (start) or right (end) alignment of the copilot button\n    alignOffset : int\n        Horizontal difference between the start points of the atom and copilot button\n    gap : int\n        Vertical difference between copilot button and atom\n    """\n    buttonLabel: str = ""\n    align: str = "start"  # or end\n    alignOffset: int = 0\n    gap: int = 0\n\n    @abstractmethod\n    def json(self) -> dict:\n        pass\n\n    @abstractmethod\n    def copilot_type(self) -> CopilotType:\n        pass\n\n\nclass CopilotButtonTypeProps(CopilotSpecProps):\n    """\n    Properties for the copilot button type\n    """\n\n    def json(self) -> dict:\n        props: dict = {\n            "buttonLabel": self.buttonLabel,\n            "align": self.align,\n            "alignOffset": self.alignOffset,\n            "gap": self.gap\n        }\n\n        return props\n\n    def copilot_type(self) -> CopilotType:\n        return CopilotType.button\n\n\nclass CopilotPromptTypeProps(CopilotSpecProps):\n    """\n    Properties for the copilot prompt type\n    ..........\n    Attributes\n    ----------\n    promptPlaceholder : Optional[str]\n        Placeholder text inside the prompt input box\n    """\n    promptPlaceholder: Optional[str] = None\n\n    def json(self) -> dict:\n        props: dict = {\n            "buttonLabel": self.buttonLabel,\n            "align": self.align,\n            "alignOffset": self.alignOffset,\n            "gap": self.gap\n        }\n\n        if self.promptPlaceholder is not None:\n            props["promptPlaceholder"] = self.promptPlaceholder\n\n        return props\n\n    def copilot_type(self) -> CopilotType:\n        return CopilotType.prompt\n\n\n@dataclass\nclass CopilotSpec:\n    """\n    The copilot properties for various atoms inside gems\n    ..........\n    Attributes\n    ----------\n    copilotProps: CopilotSpecProps\n        The copilot spec properties - button, prompt etc.\n    method : str\n        The websocket method to call\n    methodType : Optional[str]\n        The type of the message body (optional) (see usages for examples)\n    """\n    copilotProps: CopilotSpecProps\n    method: str\n    methodType: Optional[str] = None\n    autoSuggest: Optional[str] = None\n    loadingMessage: Optional[str] = None\n\n    # Copilot type is inferred from copilot props\n    def json(self):\n        props = dict()\n        props["method"] = self.method\n        if self.methodType is not None:\n            props["methodType"] = self.methodType\n        props["copilotType"] = self.copilotProps.copilot_type().to_json()\n        props["copilotProps"] = self.copilotProps.json()\n\n        return props\n\n    def withDescribeColumn(self):\n        self.method = "copilot/describe"\n        self.methodType = "CopilotDescribeColumnRequest"\n        self.copilotProps = CopilotButtonTypeProps(buttonLabel="Auto-description", align="end", gap=4)\n        return self\n\n    def withDescribeDataSource(self):\n        self.method = "copilot/describe"\n        self.methodType = "CopilotDescribeDataSourceRequest"\n        self.copilotProps = CopilotButtonTypeProps(buttonLabel="Auto-description", align="end", gap=4)\n        return self\n\n    def withGetScript(self):\n        self.method = "copilot/getScript"\n        self.copilotProps = CopilotPromptTypeProps(buttonLabel="Ask AI", align="end", alignOffset=10)\n        return self\n\n    def withGetExpression(self):\n        self.method = "copilot/getExpression"\n        self.methodType = "CopilotProjectionExpressionRequest"\n        self.copilotProps = CopilotPromptTypeProps(buttonLabel="Ask AI")\n        return self\n\n    def withSuggestGemProperties(self):\n        self.method = "copilot/suggestGemProperties"\n        self.copilotProps = CopilotButtonTypeProps(buttonLabel="Ask-AI")\n        self.loadingMessage = "Writing Transformations..."\n        return self\n\n    def withAutoSuggestUpdate(self):\n        self.autoSuggest = "update"\n        return self\n\n    def withAutoSuggestPlaceholder(self):\n        self.autoSuggest = "placeholder"\n        return self\n\n\nclass ExpressionBuilderType(Enum):\n    VALUE_EXPRESSION = "ValueExpression"\n    COLUMN_EXPRESSION = "ColumnExpression"\n    FUNCTION_EXPRESSION = "FunctionExpression"\n    CASE_EXPRESSION = "CaseExpression"\n    CONFIG_EXPRESSION = "ConfigExpression"\n    INCREMENTAL_EXPRESSION = "IncrementalExpression"\n    SQL_FUNCTION = "SQLFunction"\n    MACRO_FUNCTION = "MacroFunction"\n    CUSTOM_EXPRESSION = "CustomExpression"\n    JINJA_CONCAT_EXPRESSION = "JinjaConcatExpression"\n    CAST_AS_EXPRESSION = "CastAsExpression"\n\n\nclass ExpressionBlockType(Enum):\n    INSIDE_JINJA = "insideJinja"\n    INSIDE_CONFIG_UI = "insideConfigUI"\n\n\nclass ExpressionValueType(Enum):\n    NUMBER = "number"\n    STRING = "string"\n    BOOLEAN = "boolean"\n\n\nclass ExpressionFunctionType(Enum):\n    SQL_FUNCTION = "SQLFunction"\n    MACRO_FUNCTION = "MacroFunction"\n\n\nclass ExpressionConfigType(Enum):\n    PIPELINE = "pipeline"\n    SQL_PROJECT = "sql_project"\n    MODEL = "model"\n\n\nclass GroupBuilderType(Enum):\n    GROUP = "group"\n    EXPRESSION = "expression"\n    CONDITIONAL = "conditional"\n\nclass RowLabel(Enum):\n    Column = "Column"\n\nclass SelectMode(Enum):\n    toggle = "toggle"\n    always = "always"\n    never = "never"\n\n@dataclass\nclass VisualBuilderSpec:\n    supportedTypes: List[ExpressionBuilderType] = field(default_factory=list)\n    builderType: GroupBuilderType = GroupBuilderType.EXPRESSION\n    unsupportedTypes: List[ExpressionBuilderType] = field(default_factory=list)\n    supportedBlockType: Optional[ExpressionBlockType] = None\n    supportedValueType: Optional[ExpressionValueType] = None\n    supportedFunctionTypes: List[ExpressionFunctionType] = field(default_factory=list)\n    supportedConfigTypes: List[ExpressionConfigType] = field(default_factory=list)\n    border: Optional[bool] = None\n    placeholder: Optional[str] = None\n\n    def json(self) -> Dict[str, Any]:\n        props: Dict[str, Any] = {}\n\n        if self.unsupportedTypes is not None:\n            props["unsupportedTypes"] = [t.value for t in self.unsupportedTypes]\n        else:\n            props["supportedTypes"] = [t.value for t in self.supportedTypes]\n\n        props["builderType"] = self.builderType.value\n\n        if self.supportedBlockType is not None:\n            props["blockType"] = self.supportedBlockType.value\n\n        if self.supportedValueType is not None:\n            props["supportedValueType"] = self.supportedValueType.value\n\n        if self.supportedFunctionTypes is not None:\n            props["supportedFunctionTypes"] = [t.value for t in self.supportedFunctionTypes]\n\n        if self.supportedConfigTypes is not None:\n            props["supportedConfigTypes"] = [t.value for t in self.supportedConfigTypes]\n\n        if self.border is not None:\n            props["border"] = self.border\n\n        if self.placeholder is not None:\n            props["placeholder"] = self.placeholder\n\n        return props\n\n\'\'\' ------------------------------------ ATOMS ----------------------------\'\'\'\n\n\n@dataclass\nclass AlertBox(Container[Element]):\n    variant: str\n    banner: Optional[bool] = False\n    propertyVar: Optional[str] = None\n    _children: list = None\n\n    def title(self) -> str:\n        return "Alert"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def addElement(self, element: Element):\n        if self._children is None:\n            return replace(self, _children=[element])\n        else:\n            self._children.insert(0, element)\n            return replace(self, _children=self._children)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.Alert"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(AlertBox, self).jsonProperties()\n        if not isBlank(self.variant):\n            properties[\'variant\'] = self.variant\n        if self.banner is not None:\n            properties[\'banner\'] = self.banner\n        return properties\n\n\n@dataclass\nclass Checkbox(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    hint: Optional[str] = None\n    isChecked: Optional[bool] = False\n    helpText: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def withIsChecked(self, isChecked: bool):\n        return replace(self, isChecked=isChecked)\n\n    def withHint(self, hint: str):\n        return replace(self, hint=hint)\n\n    def withHelpText(self, helpText: str):\n        return replace(self, helpText=helpText)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def propertyKey(self) -> str:\n        return "checked"\n\n    def kind(self) -> str:\n        return "Atoms.CheckBox"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(Checkbox, self).jsonProperties()\n        properties["label"] = self.title()\n        if self.hint is not None:\n            properties["hint"] = self.hint\n        if self.isChecked is not None:\n            properties["checked"] = self.isChecked\n        if self.helpText is not None:\n            properties["helpText"] = self.helpText\n\n        return properties\n\n\n\n@dataclass\nclass Switch(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    hint: Optional[str] = None\n    disabled: Optional[bool] = False\n    checked: Optional[bool] = False\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def withChecked(self, checked: bool):\n        return replace(self, checked=checked)\n\n    def propertyKey(self) -> str:\n        return "checked"\n\n    def withDisabled(self, disabled: bool):\n        return replace(self, disabled=disabled)\n\n    def withHint(self, hint: str):\n        return replace(self, hint=hint)\n\n    def kind(self) -> str:\n        return "Atoms.Switch"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(Switch, self).jsonProperties()\n        properties["label"] = self.title()\n        if self.hint is not None:\n            properties["hint"] = self.hint\n        if self.disabled is not None:\n            properties["disabled"] = self.disabled\n        if self.checked is not None:\n            properties["checked"] = self.checked\n        return properties\n\n\n@dataclass\nclass ExpressionBox(Atom):\n    title: str = ""\n    language: Optional[str] = "${record.expression.format}"\n    placeholder: dict = dict(),\n    propertyVar: Optional[str] = None\n    selectedFields: Optional[str] = None\n    ports: Optional[str] = None\n    ignoreTitle: bool = False\n    readOnly: Optional[bool] = None\n    _kind: str = "ExpressionBox"\n    fieldType: Optional[str] = None\n    copilot: Optional[CopilotSpec] = None\n    fixWithCopilot: Optional[bool] = None\n    visualBuilder: Optional[VisualBuilderSpec] = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindLanguage(self, language: str):\n        return replace(self, language=language)\n\n    def bindSelectedFieldProperty(self, selectedFields: str):\n        return replace(self, selectedFields=selectedFields)\n\n    def bindPlaceholders(self, languagePlaceholders=None):\n        if languagePlaceholders is None:\n            languagePlaceholders = {\n                "scala": """concat(col("source_column"), col("other_column"))""",\n                "python": """concat(col("source_column"), col("other_column"))""",\n                "sql": """concat(source_column, other_column)"""}\n        return replace(self, placeholder=languagePlaceholders.copy())\n\n    def bindPlaceholder(self, placeHolder: str):\n        languagePlaceholders = {\n            "scala": placeHolder,\n            "python": placeHolder,\n            "sql": placeHolder}\n        return replace(self, placeholder=languagePlaceholders.copy())\n\n    def withFrontEndLanguage(self):\n        return replace(self, language="${$.workflow.metainfo.frontEndLanguage}")\n\n    def bindPorts(self, ports: str):\n        return replace(self, ports=ports)\n\n    def withSchemaSuggestions(self):\n        return self.bindPorts("component.ports.inputs")\n\n    def makeFieldOptional(self):\n        return replace(self, _kind="SColumn", fieldType="ExpressionBox")\n\n    def disabled(self):\n        return replace(self, readOnly=True)\n\n    # TODO: This is a temporary backup method. Will be removed later\n    def withCopilot(self, copilot: CopilotSpec):\n        return replace(self, copilot=copilot)\n    def withCopilotEnabledExpression(self):\n        copilot = CopilotSpec(method="copilot/getExpression", copilotProps=CopilotSpecProps()).withGetExpression()\n        return replace(self, copilot=copilot)\n\n\n    def allowFixWithCopilot(self):\n        return replace(self, fixWithCopilot=True)\n\n    def withVisualBuilderSpec(self, visualBuilder: VisualBuilderSpec):\n        return replace(self, visualBuilder=visualBuilder)\n\n    def withExpressionBuilder(self, visualBuilderType: List[ExpressionBuilderType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedTypes=visualBuilderType))\n\n    def withUnsupportedExpressionBuilderTypes(self, unsupportedTypes: List[ExpressionBuilderType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   unsupportedTypes=unsupportedTypes))\n\n    def withGroupBuilder(self, groupBuilderType: GroupBuilderType):\n        return replace(self,\n                       visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), builderType=groupBuilderType))\n\n    def withBlockType(self, expressionBlockType: ExpressionBlockType):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedBlockType=expressionBlockType))\n\n    def withValueType(self, valueType: ExpressionValueType):\n        return replace(self,\n                       visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), supportedValueType=valueType))\n\n    def withFunctionTypes(self, functionTypes: List[ExpressionFunctionType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedFunctionTypes=functionTypes))\n\n    def withConfigTypes(self, configTypes: List[ExpressionConfigType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedConfigTypes=configTypes))\n\n    def withBorder(self, border: bool):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), border=border))\n\n    def withVisualPlaceholder(self, placeholder: str):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), placeholder=placeholder))\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        if not self.ignoreTitle:\n            props["title"] = self.title\n        if self.language is not None:\n            props["language"] = self.language\n        if self.selectedFields is not None:\n            props["selectedFields"] = self.propertyPath(self.selectedFields)\n        if self.ports is not None:\n            props["ports"] = self.propertyPath(self.ports)\n        props["placeholder"] = self.placeholder\n        if self.readOnly is not None:\n            props["readOnly"] = self.readOnly\n        if self.fieldType is not None:\n            props["fieldType"] = self.fieldType\n        if self.copilot is not None:\n            props["copilot"] = self.copilot.json()\n        if self.fixWithCopilot is not None:\n            props["fixWithCopilot"] = self.fixWithCopilot\n        if self.visualBuilder is not None:\n            props["visualBuilder"] = self.visualBuilder.json()\n        return props\n\n@dataclass\nclass BusinessRuleBox(Atom):\n    title: str = ""\n    language: Optional[str] = "${record.expression.format}"\n    placeholder: dict = dict(),\n    propertyVar: Optional[str] = None\n    selectedFields: Optional[str] = None\n    ports: Optional[str] = None\n    ignoreTitle: bool = False\n    readOnly: Optional[bool] = None\n    _kind: str = "BusinessRule"\n    fieldType: Optional[str] = None\n    copilot: Optional[CopilotSpec] = None\n    fixWithCopilot: Optional[bool] = None\n    options: Optional[str] = None\n    paramErrors: Optional[str] = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindLanguage(self, language: str):\n        return replace(self, language=language)\n\n    def bindOptions(self, options: str):\n        return replace(self, options=options)\n\n    def bindParamErrors(self, paramErrors: str):\n        return replace(self, paramErrors=paramErrors)\n    def bindSelectedFieldProperty(self, selectedFields: str):\n        return replace(self, selectedFields=selectedFields)\n\n    def bindPlaceholders(self, languagePlaceholders=None):\n        if languagePlaceholders is None:\n            languagePlaceholders = {\n                "scala": """concat(col("source_column"), col("other_column"))""",\n                "python": """concat(col("source_column"), col("other_column"))""",\n                "sql": """concat(source_column, other_column)"""}\n        return replace(self, placeholder=languagePlaceholders.copy())\n\n    def bindPlaceholder(self, placeHolder: str):\n        languagePlaceholders = {\n            "scala": placeHolder,\n            "python": placeHolder,\n            "sql": placeHolder}\n        return replace(self, placeholder=languagePlaceholders.copy())\n\n    def withFrontEndLanguage(self):\n        return replace(self, language="${$.workflow.metainfo.frontEndLanguage}")\n\n    def bindPorts(self, ports: str):\n        return replace(self, ports=ports)\n\n    def withSchemaSuggestions(self):\n        return self.bindPorts("component.ports.inputs")\n\n    def makeFieldOptional(self):\n        return replace(self, _kind="SColumn", fieldType="ExpressionBox")\n\n    def disabled(self):\n        return replace(self, readOnly=True)\n\n    # TODO: This is a temporary backup method. Will be removed later\n    def withCopilot(self, copilot: CopilotSpec):\n        return replace(self, copilot=copilot)\n    def withCopilotEnabledExpression(self):\n        copilotSpec = CopilotSpec(method="copilot/getExpression", copilotProps=CopilotSpecProps()).withGetExpression()\n        return replace(self, copilot=copilotSpec)\n\n    def allowFixWithCopilot(self):\n        return replace(self, fixWithCopilot=True)\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        if not self.ignoreTitle:\n            props["title"] = self.title\n        if self.language is not None:\n            props["language"] = self.language\n        if self.selectedFields is not None:\n            props["selectedFields"] = self.propertyPath(self.selectedFields)\n        if self.ports is not None:\n            props["ports"] = self.propertyPath(self.ports)\n        props["placeholder"] = self.placeholder\n        if self.readOnly is not None:\n            props["readOnly"] = self.readOnly\n        if self.fieldType is not None:\n            props["fieldType"] = self.fieldType\n        if self.copilot is not None:\n            props["copilot"] = self.copilot.json()\n        if self.fixWithCopilot is not None:\n            props["fixWithCopilot"] = self.fixWithCopilot\n        if self.options is not None:\n            props["options"] = self.options\n        if self.paramErrors is not None:\n            props["paramErrors"] = self.paramErrors\n        return props\n\n\n@dataclass\nclass SelectBoxOption:\n    label: str\n    value: str\n\n\n@dataclass\nclass SelectBox(Atom):\n    titleVar: str\n    creatable: Optional[bool] = None\n    propertyVar: Optional[str] = None\n    options: list = None\n    optionProperty: Optional[str] = None\n    disabled: Optional[bool] = None\n    placeholder: Optional[str] = None\n    mode: Optional[str] = None\n    notFoundContent: Optional[str] = None\n    showSearch: Optional[bool] = None\n    footer: List[Element] = field(default_factory=list)\n    allowConfig: Optional[bool] = None\n    style: Optional[dict] = None\n    optionFilterProp: Optional[str] = None\n    _identifier: Optional[str] = None\n    valueKey: Optional[str] = None\n    labelKey: Optional[str] = None\n    optionCTA: Optional[Element] = None\n    helpText: Optional[str] = None\n    defaultValue: Optional[str] = None\n\n    def kind(self) -> str:\n        return "Atoms.SelectBox"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def withCreatable(self, key:bool):\n        return replace(self, creatable=key)\n\n    def withDefault(self, value: str):\n        return replace(self, defaultValue=value)\n\n    def withValueKey(self, key:str):\n        return replace(self, valueKey=key)\n\n    def withOptionCTA(self, cta: Element):\n        return replace(self, optionCTA=cta)\n\n    def withLabelKey(self, key:str):\n        return replace(self, labelKey=key)\n\n    def withDisabled(self):\n        return replace(self, disabled=True)\n\n    def withStyle(self, style: dict):\n        return replace(self, style=style)\n\n    def withAllowConfig(self):\n        return replace(self, allowConfig=True)\n\n    def identifier(self) -> Optional[str]:\n        return self._identifier\n\n    def withIdentifier(self, identifier: str):\n        return replace(self, _identifier=identifier)\n\n    def withFilterProp(self, filterProp: str):\n        return replace(self, optionFilterProp=filterProp)\n\n    def withNoContentMessage(self, msg: str):\n        return replace(self, notFoundContent=msg)\n\n    def bindOptionProperty(self, property: str):\n        return replace(self, optionProperty=property)\n\n    def withSearchEnabled(self):\n        return replace(self, showSearch=True)\n\n    def addFooter(self, element: Element):\n        if len(self.footer) == 0:\n            return replace(self, footer=[element])\n        else:\n            self.footer.append(element)\n            return replace(self, footer=self.footer)\n\n    def getTemplateElements(self):\n        return self.footer\n\n    def addOption(self, label: str, value: str):\n        if self.options is not None:\n            self.options.append(SelectBoxOption(label, value))\n            return replace(self, options=self.options)\n        else:\n            return replace(self, options=[SelectBoxOption(label, value)])\n\n    def withHelpText(self, helpText: str):\n        return replace(self, helpText=helpText)\n\n    def jsonProperties(self) -> dict:\n        properties = super(SelectBox, self).jsonProperties()\n        optionsJsonArray = []\n\n        if self.identifier() is not None:\n            properties["identifier"] = self.identifier()\n        if self.disabled is not None:\n            properties["disabled"] = self.disabled\n        if self.placeholder is not None:\n            properties["placeholder"] = self.placeholder\n        if self.mode is not None:\n            properties["mode"] = self.mode\n        if self.notFoundContent is not None:\n            properties["notFoundContent"] = self.notFoundContent\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.allowConfig is not None:\n            properties["allowConfig"] = self.allowConfig\n        if self.showSearch is not None:\n            properties["showSearch"] = self.showSearch\n        if self.optionFilterProp is not None:\n            properties["optionFilterProp"] = self.optionFilterProp\n        if self.helpText is not None:\n            properties["helpText"] = self.helpText\n        if self.optionProperty is not None:\n            properties["options"] = self.optionProperty\n        if self.creatable is not None:\n            properties["creatable"] = self.creatable\n        elif self.options is not None:\n            for curOpt in self.options:\n                optionsJsonArray.append({"label": curOpt.label, "value": curOpt.value})\n            properties["options"] = optionsJsonArray\n\n        if self.valueKey is not None:\n            properties["valueKey"] = self.valueKey\n\n        if self.labelKey is not None:\n            properties["labelKey"] = self.labelKey\n\n        footerJsons = []\n        for footer in self.footer:\n            footerJsons.append(footer.json())\n\n        if self.optionCTA is not None:\n            properties["optionCTA"] = self.optionCTA.json()\n\n        if self.defaultValue is not None:\n            properties["defaultValue"] = self.defaultValue\n\n        properties["footer"] = footerJsons\n        return properties\n\n\n@dataclass\nclass NumberBox(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    minValueVar: Optional[int] = None\n    maxValueVar: Optional[int] = None\n    ignoreTitle: bool = False\n    placeholder: str = ""\n    disabledView: Optional[bool] = None\n    textType: Optional[str] = None\n    allowEscapeSequence: Optional[bool] = None\n    _kind: str = "Atoms.NumberBox"\n    fieldType: Optional[str] = None\n    helpText: Optional[str] = None\n    requiredMin: bool = True\n    min: int = 0\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def minValue(self) -> Optional[int]:\n        return self.minValueVar\n\n    def maxValue(self) -> Optional[int]:\n        return self.maxValueVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property_input: str):\n        return replace(self, propertyVar=property_input)\n\n    def bindPlaceholder(self, placeholder_input: str):\n        return replace(self, placeholder=placeholder_input)\n\n    def disabled(self):\n        return replace(self, disabledView=True)\n\n    def enableEscapeSequence(self):\n        return replace(self, allowEscapeSequence=True)\n\n    def makeFieldOptional(self):\n        return replace(self, _kind="SColumn", fieldType="Atoms.NumberBox")\n\n    def withHelpText(self, helpText: str):\n        return replace(self, helpText=helpText)\n\n    def withRequiredMin(self, requiredMin: int):\n        return replace(self, requiredMin=requiredMin)\n\n    def withMin(self, min: int):\n        return replace(self, min=min)\n\n\n    def jsonProperties(self) -> dict:\n        props = super(NumberBox, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        if self.minValue is not None:\n            props["min"] = self.minValue()\n        if self.maxValue is not None:\n            props["max"] = self.maxValue()\n        if self.disabledView is not None:\n            props["disabled"] = self.disabledView\n        if self.fieldType is not None:\n            props["fieldType"] = self.fieldType\n        if self.textType is not None:\n            props["type"] = self.textType\n        if self.allowEscapeSequence is not None:\n            props["allowEscapeSequence"] = self.allowEscapeSequence\n        if self.helpText is not None:\n            props["helpText"] = self.helpText\n\n        props["requiredMin"] = self.requiredMin\n        props["min"] = self.min\n        props["placeholder"] = self.placeholder\n        return props\n\n\n@dataclass\nclass Markdown(Atom):\n    valueVar: str\n    propertyVar: Optional[str] = None\n    _kind: str = "Atoms.Markdown"\n\n    def title(self) -> str:\n        return ""\n\n    def value(self) -> str:\n        return self.valueVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        props = super(Markdown, self).jsonProperties()\n        if self.valueVar is not None:\n            props["value"] = self.value()\n        return props\n\n\n@dataclass\nclass FileUploadBox(Atom):\n    titleVar: str\n    _kind: str = "Atoms.FileUploadBox"\n    placeholder: str = "Upload file"\n    ignoreTitle: bool = False\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def jsonProperties(self) -> dict:\n        props = super(FileUploadBox, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        props["placeholder"] = self.placeholder\n        return props\n\n\n@dataclass\nclass ConfigText(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    ignoreTitle: bool = False\n    _kind: str = "Atoms.ConfigText"\n    placeholder: str = "target_column"\n    disabledView: Optional[Union[list, bool]] = None\n    textType: Optional[str] = None\n    allowEscapeSequence: Optional[bool] = None\n    allowConfig: Optional[bool] = None\n    fieldType: Optional[str] = None\n    allowComposite: Optional[bool] = None\n    rows: Optional[int] = None\n    resetTrigger: Optional[str] = None\n    width: Optional[str] = None\n    helpText: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withWidth(self, width: str):\n        return replace(self, width=width)\n\n    def withResetTrigger(self, property: str):\n        return replace(self, resetTrigger=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def disabled(self):\n        return replace(self, disabledView=True)\n\n    def enableEscapeSequence(self):\n        return replace(self, allowEscapeSequence=True)\n\n    def isPassword(self):\n        return replace(self, textType="password")\n\n    def withRows(self, rows: int):\n        return replace(self, rows=rows)\n\n    def makeFieldOptional(self):\n        return replace(self, _kind="SColumn", fieldType="Atoms.ConfigText")\n\n    def withAllowConfig(self):\n        return replace(self, allowConfig=True)\n\n    def withAllowComposite(self, flag: bool = True):\n        return replace(self, allowComposite=flag)\n\n    def withHelpText(self, helpText: str):\n        return replace(self, helpText=helpText)\n\n\n    def jsonProperties(self) -> dict:\n        props = super(ConfigText, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        if self.disabledView is not None:\n            props["disabled"] = self.disabledView\n        if self.fieldType is not None:\n            props["fieldType"] = self.fieldType\n        if self.textType is not None:\n            props["type"] = self.textType\n        if self.allowEscapeSequence is not None:\n            props["allowEscapeSequence"] = self.allowEscapeSequence\n        if self.allowConfig is not None:\n            props["allowConfig"] = self.allowConfig\n        if self.allowComposite is not None:\n            props["allowComposite"] = self.allowComposite\n        if self.rows is not None:\n            props["rows"] = self.rows\n        if self.helpText is not None:\n            props["helpText"] = self.helpText\n        if self.resetTrigger is not None:\n            props["resetTrigger"] = self.resetTrigger\n        if self.width is not None:\n            props["width"] = self.width\n        props["placeholder"] = self.placeholder\n        return props\n\n\n\n@dataclass\nclass SqlSecretSelector(Atom):\n    titleVar: str\n    _kind: str = "Atoms.SqlSecretSelector"\n    placeholder: str = "Upload file"\n    ignoreTitle: bool = False\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def jsonProperties(self) -> dict:\n        props = super(SqlSecretSelector, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        props["placeholder"] = self.placeholder\n        return props\n\n@dataclass\nclass SqlFileSystemUpload(Atom):\n    titleVar: str\n    _kind: str = "Atoms.SqlFileSystemUpload"\n    formats: list = ("xlsx")\n    placeholder: str = "Upload formatted XLSX"\n    ignoreTitle: bool = False\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def propertyKey(self) -> str:\n        return "path"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def jsonProperties(self) -> dict:\n        props = super(SqlFileSystemUpload, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        props["placeholder"] = self.placeholder\n        props["formats"] = self.formats\n        return props\n\n@dataclass\nclass ConnectionDropdown(Atom):\n    connectionKind: str\n    titleVar: str\n    _kind: str = "Atoms.ConnectionDropdown"\n    placeholder: str = "Select Connection"\n    ignoreTitle: bool = False\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def bindConnectionKind(self, connectionKind: str):\n        return replace(self, connectionKind=connectionKind)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def jsonProperties(self) -> dict:\n        props = super(ConnectionDropdown, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        props["placeholder"] = self.placeholder\n        props["connectionKind"] = self.connectionKind\n        return props\n\n@enum.unique\nclass AddOnPlacement(enum.Enum):\n    left = "left"\n    right = "right"\n\n    def getEnum(value):\n        if value == "left":\n            return AddOnPlacement.left\n        elif value == "right":\n            return AddOnPlacement.right\n        else:\n            return AddOnPlacement.left\n\n@dataclass\nclass TextBox(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    ignoreTitle: bool = False\n    _kind: str = "Atoms.TextBox"\n    placeholder: str = "target_column"\n    disabledView: Optional[Union[list, bool]] = None\n    textType: Optional[str] = None\n    allowEscapeSequence: Optional[bool] = None\n    allowConfig: Optional[bool] = None\n    fieldType: Optional[str] = None\n    allowComposite: Optional[bool] = None\n    rows: Optional[int] = None\n    resetTrigger: Optional[str] = None\n    width: Optional[str] = None\n    helpText: Optional[str] = None\n    addOn: Optional[str] = None\n    addOnPlacement: Optional[AddOnPlacement] = None\n    required: Optional[bool] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withWidth(self, width: str):\n        return replace(self, width=width)\n\n    def withResetTrigger(self, property: str):\n        return replace(self, resetTrigger=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def disabled(self):\n        return replace(self, disabledView=True)\n\n    def enableEscapeSequence(self):\n        return replace(self, allowEscapeSequence=True)\n\n    def isPassword(self):\n        return replace(self, textType="password")\n\n    def withRows(self, rows: int):\n        return replace(self, rows=rows)\n\n    def makeFieldOptional(self):\n        return replace(self, _kind="SColumn", fieldType="Atoms.TextBox")\n\n    def withAllowConfig(self):\n        return replace(self, allowConfig=True)\n\n    def withAllowComposite(self, flag: bool = True):\n        return replace(self, allowComposite=flag)\n\n    def withHelpText(self, helpText: str):\n        return replace(self, helpText=helpText)\n\n    def withAddOn(self, addOn: str):\n        return replace(self, addOn=addOn)\n\n    # must be either \'left\' or \'right\'\n    def withAddOnPlacement(self, addOnPlacement: AddOnPlacement):\n        return replace(self, addOnPlacement=addOnPlacement.value)\n\n    def withRequired(self, required: bool):\n        return replace(self, required=required)\n\n    def jsonProperties(self) -> dict:\n        props = super(TextBox, self).jsonProperties()\n        if not self.ignoreTitle:\n            props["title"] = self.title()\n        if self.disabledView is not None:\n            props["disabled"] = self.disabledView\n        if self.fieldType is not None:\n            props["fieldType"] = self.fieldType\n        if self.textType is not None:\n            props["type"] = self.textType\n        if self.allowEscapeSequence is not None:\n            props["allowEscapeSequence"] = self.allowEscapeSequence\n        if self.allowConfig is not None:\n            props["allowConfig"] = self.allowConfig\n        if self.allowComposite is not None:\n            props["allowComposite"] = self.allowComposite\n        if self.rows is not None:\n            props["rows"] = self.rows\n        if self.helpText is not None:\n            props["helpText"] = self.helpText\n        if self.resetTrigger is not None:\n            props["resetTrigger"] = self.resetTrigger\n        if self.width is not None:\n            props["width"] = self.width\n        if self.addOn is not None:\n            props["addOn"] = self.addOn\n        if self.addOnPlacement is not None:\n            props["addOnPlacement"] = self.addOnPlacement\n        if self.required is not None:\n            props["required"] = self.required\n        props["placeholder"] = self.placeholder\n        return props\n\n\n@dataclass\nclass TextArea(Atom):\n    titleVar: str\n    rows: int\n    propertyVar: Optional[str] = None\n    _kind: str = "Atoms.TextArea"\n    placeholder: str = ""\n    allowEscapeSequence: Optional[bool] = None\n    readOnly: bool = False\n    copilot: Optional[CopilotSpec] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def enableEscapeSequence(self):\n        return replace(self, allowEscapeSequence=True)\n\n    # TODO: This is a temporary backup method. Will be removed later\n    def withCopilot(self, copilot: CopilotSpec):\n        return replace(self, copilot=copilot)\n    def withCopilotEnabledDescribeColumn(self):\n        copilotSpec = CopilotSpec(method="", copilotProps=CopilotSpecProps()).withDescribeColumn()\n        return replace(self, copilot=copilotSpec)\n\n    def withCopilotEnabledDescribeDataSource(self):\n        copilotSpec = CopilotSpec(method="", copilotProps=CopilotSpecProps()).withDescribeDataSource()\n        return replace(self, copilot=copilotSpec)\n\n    def jsonProperties(self) -> dict:\n        props = super(TextArea, self).jsonProperties()\n        props["title"] = self.title()\n        props["rows"] = self.rows\n        if self.allowEscapeSequence is not None:\n            props["allowEscapeSequence"] = self.allowEscapeSequence\n        props["placeholder"] = self.placeholder\n        if self.readOnly:\n            props["readOnly"] = self.readOnly\n        if self.copilot is not None:\n            props["copilot"] = self.copilot.json()\n        return props\n\n\n@dataclass(frozen=True)\nclass RadioOption:\n    label: str\n    value: str\n    icon: Optional[str] = None\n    description: Optional[str] = None\n\n\n@dataclass\nclass RadioGroup(Atom):\n    _title: str\n    propertyVar: Optional[str] = None\n    optionProperty: Optional[str] = None\n    optionType: Optional[str] = None\n    options: list = None\n    gap: Optional[str] = "1rem"\n    variant: Optional[str] = None\n    buttonStyle: Optional[str] = None\n    buttonSize: Optional[str] = None\n    iconSize: Optional[str] = None\n    style: Optional[dict] = None\n    defaultValue: Optional[str] = None\n    orientation: Optional[str] = None\n\n    def kind(self) -> str:\n        return "Atoms.RadioGroup"\n\n    def title(self) -> str:\n        return self._title\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindOptionProperty(self, property: str):\n        return replace(self, optionProperty=property)\n\n    def addOption(self, label: str, value: str, icon: Optional[str] = None, description: Optional[str] = None\n                  ):\n        if self.options is not None:\n            self.options.append(RadioOption(label, value, icon, description))\n            return replace(self, options=self.options)\n        else:\n            return replace(self, options=[RadioOption(label, value, icon, description)])\n\n    def setOptionType(self, optionType: str):\n        return replace(self, optionType=optionType)\n\n    def setVariant(self, variant: str):\n        return replace(self, variant=variant)\n\n    def setButtonStyle(self, buttonStyle: str):\n        return replace(self, buttonStyle=buttonStyle)\n\n    def setButtonSize(self, buttonSize: str):\n        return replace(self, buttonSize=buttonSize)\n\n    def jsonProperties(self) -> dict:\n        properties = super(RadioGroup, self).jsonProperties()\n        if self.optionProperty is not None:\n            properties["options"] = self.optionProperty\n        elif self.options is not None:\n            optionsJsonArray = []\n            for opt in self.options:\n                optionsJsonArray.append({\n                    "label": opt.label, "value": opt.value, "icon": opt.icon, "description": opt.description\n                })\n            properties["options"] = optionsJsonArray\n        if self.gap is not None:\n            properties["gap"] = self.gap\n        if self.variant is not None:\n            properties["variant"] = self.variant\n        if self.optionType is not None:\n            properties["optionType"] = self.optionType\n        if self.buttonStyle is not None:\n            properties["buttonStyle"] = self.buttonStyle\n\n        if self.buttonSize is not None:\n            properties["buttonSize"] = self.buttonSize\n        if self.iconSize is not None:\n            properties["iconSize"] = self.iconSize\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.defaultValue is not None:\n            properties["defaultValue"] = self.defaultValue\n        if self.orientation is not None:\n            properties["orientation"] = self.orientation\n\n        return properties\n\n\n@dataclass\nclass NativeText(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.NativeText"\n\n    def bindProperty(self, property: str):\n        return self\n\n    def jsonProperties(self) -> dict:\n        properties = super(NativeText, self).jsonProperties()\n        properties["value"] = self.title()\n        return properties\n\n@dataclass\nclass Editor(Atom):\n    height: Optional[str] = "100%"\n    language: Optional[str] = "${$.workflow.metainfo.frontEndLanguage}"\n    _kind: str = "Atoms.Editor"\n    ports: Optional[str] = None\n    propertyVar: Optional[str] = None\n    fieldType: Optional[str] = None\n    visualBuilder: Optional[VisualBuilderSpec] = None\n\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def title(self) -> str:\n        return "Editor"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindLanguage(self, lang: str):\n        return replace(self, language=lang)\n\n    def withSchemaSuggestions(self):\n        return replace(self, ports="component.ports.inputs")\n\n    def makeFieldOptional(self):\n        return replace(self, _kind="SColumn", fieldType="Atoms.Editor")\n\n    def withVisualBuilderSpec(self, visualBuilder: VisualBuilderSpec):\n        return replace(self, visualBuilder=visualBuilder)\n\n    def withExpressionBuilder(self, visualBuilderType: List[ExpressionBuilderType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedTypes=visualBuilderType))\n\n    def withUnsupportedExpressionBuilderTypes(self, unsupportedTypes: List[ExpressionBuilderType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   unsupportedTypes=unsupportedTypes))\n\n    def withGroupBuilder(self, groupBuilderType: GroupBuilderType):\n        return replace(self,\n                       visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), builderType=groupBuilderType))\n\n    def withBlockType(self, expressionBlockType: ExpressionBlockType):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedBlockType=expressionBlockType))\n\n    def withValueType(self, valueType: ExpressionValueType):\n        return replace(self,\n                       visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), supportedValueType=valueType))\n\n    def withFunctionTypes(self, functionTypes: List[ExpressionFunctionType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedFunctionTypes=functionTypes))\n\n    def withConfigTypes(self, configTypes: List[ExpressionConfigType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedConfigTypes=configTypes))\n\n    def withBorder(self, border: bool):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), border=border))\n\n    def withVisualPlaceholder(self, placeholder: str):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), placeholder=placeholder))\n\n    def jsonProperties(self) -> dict:\n        props = {"title": self.title(), "language": self.language}\n        if self.height is not None:\n            props["height"] = self.height\n        else:\n            props["height"] = "100px"\n        if self.fieldType is not None:\n            props["fieldType"] = self.fieldType\n        if self.ports is not None:\n            props["ports"] = self.propertyPath(self.ports)\n        if self.visualBuilder is not None:\n            props["visualBuilder"] = self.visualBuilder.json()\n        return props\n\n\n@enum.unique\nclass Gem(enum.Enum):\n    DiamondPurple = "DiamondPurple"\n    TrillionOrange = "TrillionOrange"\n\n    @staticmethod\n    def get_enum(value):\n        if value == "DiamondPurple":\n            return Gem.DiamondPurple\n        elif value == "TrillionOrange":\n            return Gem.TrillionOrange\n\n\n@enum.unique\nclass ButtonVariant(enum.Enum):\n    primary = "primary"\n    secondary = "secondary"\n    secondaryGrey = "secondaryGrey"\n    tertiary = "tertiary"\n    tertiaryGrey = "tertiaryGrey"\n    link = "link"\n    linkGrey = "linkGrey"\n    plain = "plain"\n\n    def getEnum(value):\n        if value == "primary":\n            return ButtonVariant.primary\n        elif value == "secondary":\n            return ButtonVariant.secondary\n        elif value == "secondaryGrey":\n            return ButtonVariant.secondaryGrey\n        elif value == "tertiary":\n            return ButtonVariant.tertiary\n        elif value == "tertiaryGrey":\n            return ButtonVariant.tertiaryGrey\n        elif value == "link":\n            return ButtonVariant.link\n        elif value == "linkGrey":\n            return ButtonVariant.linkGrey\n        else:\n            return ButtonVariant.plain\n\n\n@enum.unique\nclass ButtonSize(enum.Enum):\n    xs = "xs"\n    s = "s"\n    m = "m"\n    l = "l"\n    xl = "xl"\n\n    def getEnum(value):\n        if value == "xs":\n            return ButtonSize.xs\n        elif value == "s":\n            return ButtonSize.s\n        elif value == "m":\n            return ButtonSize.m\n        elif value == "l":\n            return ButtonSize.l\n        else:\n            return ButtonSize.xl\n\n\n@enum.unique\nclass ButtonShape(enum.Enum):\n    default = "default"\n    circle = "circle"\n\n    def getEnum(value):\n        if value == "default":\n            return ButtonShape.default\n        else:\n            return ButtonShape.circle\n\n\n@enum.unique\nclass FontLevel(enum.Enum):\n    xl = "xl"\n    lg = "lg"\n    md = "md"\n    sm15 = "sm15"\n    sm = "sm"\n    sm13 = "sm13"\n    xs = "xs"\n    xxs = "xxs"\n\n    def getEnum(value):\n        if value == "xs":\n            return FontLevel.xs\n        elif value == "lg":\n            return FontLevel.lg\n        elif value == "md":\n            return FontLevel.md\n        elif value == "sm15":\n            return FontLevel.sm15\n        elif value == "sm":\n            return FontLevel.sm\n        elif value == "sm13":\n            return FontLevel.sm13\n        elif value == "xxs":\n            return FontLevel.xxs\n        else:\n            return FontLevel.xl\n\n\n@dataclass\nclass Button(Container[Element]):\n    titleVar: str\n    variant: Optional[ButtonVariant] = ButtonVariant.secondaryGrey\n    shape: Optional[ButtonShape] = None\n    size: Optional[ButtonSize] = None\n    style: Optional[dict] = None\n    _children: list = None\n    onClick: Optional = None\n    danger: Optional[bool] = None\n    block: Optional[bool] = None\n    href: Optional[str] = None\n\n    def jsonProperties(self) -> dict:\n        properties = super(Button, self).jsonProperties()\n        if self.variant is not None:\n            properties["variant"] = self.variant.value\n        if self.shape is not None:\n            properties["shape"] = self.shape.value\n        if self.size is not None:\n            properties["size"] = self.size.value\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.danger is not None:\n            properties["danger"] = self.danger\n        if self.block is not None:\n            properties["block"] = self.block\n        if self.onClick is not None:\n            properties["actions"] = ["onButtonClick"]\n        if self.href is not None:\n            properties["href"] = self.href\n        return properties\n\n    def bindOnClick(self, onClick):\n        return replace(self, onClick=onClick)\n\n    def kind(self) -> str:\n        return "Atoms.Button"\n\n    def title(self):\n        return self.titleVar\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def withHref(self, href: str):\n        return replace(self, href=href)\n\n    def addElement(self, child: Element):\n        if self._children is None:\n            return replace(self, _children=[child])\n        else:\n            self._children.insert(0, child)\n        return replace(self, _children=self._children)\n\n\n@dataclass\nclass Step(Container[Element]):\n    _children: List[Element] = field(default_factory=list)\n    grow: Optional[int] = 0\n    shrink: Optional[int] = 1\n    basis: Optional[str] = "auto"\n    style: Optional[Dict[str, str]] = None\n    align: Optional[str] = None\n    padding: Optional[str] = None\n\n    def kind(self) -> str:\n        return "Layouts.Step"\n\n    def addElement(self, child: Element):\n        self._children.append(child)\n        return self\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def jsonProperties(self) -> dict:\n        properties = super(Step, self).jsonProperties()\n        if self.grow is not None:\n            properties["grow"] = self.grow\n        if self.shrink is not None:\n            properties["shrink"] = self.shrink\n        if self.basis is not None:\n            properties["basis"] = self.basis\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.align is not None:\n            properties["align"] = self.align\n        if self.padding is not None:\n            properties["padding"] = self.padding\n\n        return properties\n\n@dataclass\nclass StepContainer(Container[Element]):\n    gap: Optional[str] = "1rem"\n    direction: Optional[str] = None\n    align: Optional[str] = None\n    width: Optional[str] = None\n    alignY: Optional[str] = None\n    height: Optional[str] = None\n    _children: List[Element] = field(default_factory=list)\n    padding: Optional[str] = None\n    style: Optional[Dict[str, str]] = None\n    template: Optional[Element] = None\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Layouts.StepContainer"\n\n    def addElement(self, child: Element):\n        return replace(self, _children=self._children + [child])\n\n    def addStackItem(self, child: Element):\n        return replace(self, _children=self._children + [child])\n\n    def addTemplate(self, template: Element):\n        return replace(self, template=template)\n\n    def jsonProperties(self) -> dict:\n        properties = super(StepContainer, self).jsonProperties()\n        if self.gap is not None:\n            properties["gap"] = self.gap\n        if self.direction is not None:\n            properties["direction"] = self.direction\n        if self.align is not None:\n            properties["align"] = self.align\n        if self.width is not None:\n            properties["width"] = self.width\n        if self.alignY is not None:\n            properties["alignY"] = self.alignY\n        if self.height is not None:\n            properties["height"] = self.height\n        if self.template is not None:\n            properties["template"] = self.template.json()\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.padding is not None:\n            properties["padding"] = self.padding\n\n        return properties\n\nclass JoinIconEnum(Enum):\n    INNER_JOIN = "InnerJoin"\n    LEFT_OUTER_JOIN = "LeftOuterJoin"\n    RIGHT_OUTER_JOIN = "RightOuterJoin"\n    FULL_OUTER = "FullOuter"\n    CROSS_JOIN = "CrossJoin"\n    DEFAULT = "Default"\n    NATURAL_INNER_JOIN = "NaturalInnerJoin"\n    NATURAL_LEFT_OUTER_JOIN = "NaturalLeftOuterJoin"\n    NATURAL_RIGHT_OUTER_JOIN = "NaturalRightOuterJoin"\n    NATURAL_FULL_OUTER = "NaturalFullOuter"\n\n\n@dataclass\nclass JoinType():\n    displayName: str\n    name: str\n    description: str\n    icon: JoinIconEnum = JoinIconEnum.DEFAULT,\n    tooltip: Optional[str] = None\n\n    def json(self):\n        properties = {}\n        properties["displayName"] = self.displayName\n        properties["name"] = self.name\n        properties["description"] = self.description\n        properties["icon"] = self.icon.value\n        if self.tooltip is not None:\n            properties["tooltip"] = self.tooltip\n        return properties\n\n\n@dataclass\nclass JoinConditionsAtom(Atom):\n    value: str\n    headAlias: str\n    joinTypes: List[JoinType] = field(default_factory=list)\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return ""\n\n    def kind(self) -> str:\n        return "Atoms.JoinConditions"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindValue(self, value: str):\n        return replace(self, value=value)\n\n    def bindProperty(self, value: str):\n        return replace(self, value=value)\n\n    def bindHeadAlias(self, headAlias: str):\n        return replace(self, headAlias=headAlias)\n\n    def bindJoinTypes(self, joinTypes: List[JoinType]):\n        return replace(joinTypes=joinTypes)\n\n    def addJoinType(self, joinType: JoinType):\n        return replace(self, joinTypes=self.joinTypes + [joinType])\n\n    def jsonProperties(self) -> dict:\n        properties = super(JoinConditionsAtom, self).jsonProperties()\n        properties["value"] = self.value\n        properties["headAlias"] = self.headAlias\n        properties["joinTypes"] = [jt.json() for jt in self.joinTypes]\n        return properties\n\n@dataclass\nclass IDELinkButton(Button):\n    ide:Optional[str] = None\n    projectId:Optional[str] = None\n    entityId:Optional[str] = None\n    action:Optional[str] = None\n    entityType:Optional[str] = None\n    openInNewTab:Optional[bool] = None\n    navigatingTo:Optional[str] = None\n\n    def kind(self) -> str:\n        return "Atoms.IDELinkButton"\n\n    def withOpenInNewTab(self, openInNewTab: bool):\n        return replace(self, openInNewTab=openInNewTab)\n\n    def withIDE(self, ide: str):\n        return replace(self, ide=ide)\n\n    def withEntityType(self, entityType: str):\n        return replace(self, entityType=entityType)\n\n    def withProjectId(self, projectId: str):\n        return replace(self, projectId=projectId)\n\n    def withEntityId(self, entityId: str):\n        return replace(self, entityId=entityId)\n\n    def withAction(self, action: str):\n        return replace(self, action=action)\n\n    def withNavigateTo(self, msg: str):\n        return replace(self, navigatingTo=msg)\n\n\n    def jsonProperties(self) -> dict:\n        properties = super(IDELinkButton, self).jsonProperties()\n        if self.ide is not None:\n            properties["ide"] = self.ide\n        if self.projectId is not None:\n            properties["projectId"] = self.projectId\n        if self.entityId is not None:\n            properties["entityId"] = self.entityId\n        if self.action is not None:\n            properties["action"] = self.action\n        if self.entityType is not None:\n            properties["entityType"] = self.entityType\n        if self.openInNewTab is not None:\n            properties["openInNewTab"] = self.openInNewTab\n        if self.navigatingTo is not None:\n            properties["navigatingTo"] = self.navigatingTo\n\n        return properties\n\n\n@dataclass\nclass ProphecyIcon(Atom):\n    type: Optional[str] = None\n    iconName: Optional[str] = None\n    color: Optional[str] = None\n\n    def title(self) -> str:\n        return ""\n\n    def property(self) -> Optional[str]:\n        pass\n\n    def bindProperty(self, property: str):\n        pass\n\n    def kind(self) -> str:\n        return "Atoms.ProphecyIcon"\n\n    def withType(self, type: str):\n        return replace(self, type=type)\n\n    def withIconName(self, iconName: str):\n        return replace(self, iconName=iconName)\n\n    def withColor(self, color: str):\n        return replace(self, color=color)\n\n    def jsonProperties(self) -> dict:\n        properties = super(ProphecyIcon, self).jsonProperties()\n        if self.type is not None:\n            properties["type"] = self.type\n        if self.iconName is not None:\n            properties["iconName"] = self.iconName\n        if self.color is not None:\n            properties["color"] = self.color\n        return properties\n\n@dataclass\nclass FabricIcon(Atom):\n    providerType: Optional[str] = None\n    provider: Optional[str] = None\n\n    def title(self) -> str:\n        return ""\n\n    def property(self) -> Optional[str]:\n        pass\n\n    def bindProperty(self, property: str):\n        pass\n\n    def kind(self) -> str:\n        return "Atoms.FabricIcon"\n\n\n    def withProviderType(self, providerType: str):\n        return replace(self, providerType=providerType)\n\n    def withProvider(self, provider: str):\n        return replace(self, provider=provider)\n\n    def jsonProperties(self) -> dict:\n        properties = super(FabricIcon, self).jsonProperties()\n        if self.providerType is not None:\n            properties["providerType"] = self.providerType\n        if self.provider is not None:\n            properties["provider"] = self.provider\n        return properties\n@dataclass\nclass Code(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.Code"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n@dataclass\nclass CodeBlock(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    languageVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.CodeBlock"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindCodeLanguage(self, language: str):\n        return replace(self, languageVar=language)\n\n    def propertyKey(self) -> str:\n        return "code"\n\n    def jsonProperties(self) -> dict:\n        properties = super(CodeBlock, self).jsonProperties()\n        if self.languageVar is not None:\n            properties["language"] = self.languageVar\n        return properties\n\n\n@dataclass\nclass PortSchemaType:\n    nameVar: str = ""\n\n    def name(self) -> str:\n        return self.nameVar\n\n\n@enum.unique\nclass PortSchemaTypeEnum(enum.Enum):\n    InputSchema = "in"\n    OutputSchema = "out"\n    AnySchema = "Any"\n\n    def getEnum(value):\n        if value == "Input":\n            return PortSchemaTypeEnum.InputSchema\n        elif value == "Output":\n            return PortSchemaTypeEnum.OutputSchema\n        else:\n            return PortSchemaTypeEnum.AnySchema\n\n\n# This represents the new Ports Atom which encapsulates both input & output tabs.\n# This is so that UI can have better control on rendering them.\n@dataclass\nclass Ports(Atom):\n    propertyVar: Optional[str] = None\n    singleColumnClickCallback: Optional = None\n    allColumnsSelectionCallback: Optional = None\n    minInputPorts: Union[int, str] = 0\n    minOutputPorts: Union[int, str] = 0\n    allowInputRename: Union[bool, str] = False\n    allowOutputRename: Union[bool, str] = False\n    selectedFieldsProperty: Optional[str] = None\n    inputPorts: str = "${component.ports.inputs}"\n    outputPorts: str = "${component.ports.outputs}"\n    inputNoFieldsMessage: str = "Please connect input ports and fix upstream gems to see schema"\n    outputNoFieldsMessage: str = "Please fix gem errors and upstream gems to see schema"\n    allowInputAddOrDelete: Union[bool, str] = False\n    allowOutputAddOrDelete: Union[bool, str] = False\n    allowCustomOutputSchema: bool = True\n    defaultCustomOutputSchema: bool = False\n    allowInputSelection: Optional[bool] = None\n    allowInputSelectionProperty: Optional[str] = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return "Schema"\n\n    def kind(self) -> str:\n        return "Ports"\n\n    def bindSelectedFieldsProperty(self, property: str):\n        return replace(self, selectedFieldsProperty=property)\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def allowColumnClickBasedOn(self, propertyPath: str):\n        return replace(self, allowInputSelectionProperty=(propertyPath))\n\n    def editableInput(self, editableFlag: bool):\n        return replace(self, allowInputAddOrDelete=editableFlag, allowInputRename=editableFlag)\n\n    def jsonProperties(self) -> dict:\n        properties = super(Ports, self).jsonProperties()\n        properties["id"] = self.id\n\n        actions = list()\n        if self.singleColumnClickCallback is not None:\n            actions.append("onColumnClick")\n        if self.allColumnsSelectionCallback is not None:\n            actions.append("onSelectAllColumns")\n        if len(actions) > 0:\n            properties["actions"] = actions\n\n        properties["minInputPorts"] = self.minInputPorts\n        properties["minOutputPorts"] = self.minOutputPorts\n        properties["allowInputRename"] = self.allowInputRename\n        properties["allowOutputRename"] = self.allowOutputRename\n\n        if self.selectedFieldsProperty is not None:\n            properties["selectedFields"] = self.propertyPath(self.selectedFieldsProperty)\n\n        properties["inputPorts"] = self.inputPorts\n        properties["outputPorts"] = self.outputPorts\n        properties["inputNoFieldsMessage"] = self.inputNoFieldsMessage\n        properties["outputNoFieldsMessage"] = self.outputNoFieldsMessage\n        properties["allowInputAddOrDelete"] = self.allowInputAddOrDelete\n        properties["allowOutputAddOrDelete"] = self.allowOutputAddOrDelete\n        properties["allowCustomOutputSchema"] = self.allowCustomOutputSchema\n        properties["defaultCustomOutputSchema"] = self.defaultCustomOutputSchema\n        properties["isCustomOutputSchema"] = self.propertyPath("component.ports.isCustomOutputSchema")\n\n        if self.allowInputSelection is not None:\n            properties["allowInputSelection"] = self.allowInputSelection\n        elif self.allowInputSelectionProperty is not None:\n            properties["allowInputSelection"] = self.propertyPath(self.allowInputSelectionProperty)\n        elif (self.singleColumnClickCallback is not None) or (self.allColumnsSelectionCallback is not None):\n            properties["allowInputSelection"] = True\n\n        return properties\n\n\n@dataclass\nclass PortSchema(Atom):\n    schemaType: PortSchemaTypeEnum = PortSchemaTypeEnum.AnySchema\n    selectedFieldsProperty: Optional[str] = None\n    propertyVar: Optional[str] = None\n    ports: Optional[str] = None\n    minPorts: Union[int, str] = 0\n    allowSelection: Optional[bool] = False\n    onColumnClicked: Optional = None\n    allowRename: Union[bool, str] = False\n    onAllColumnsClicked: Optional = None\n    allowAddOrDelete: Union[bool, str] = False\n    noSchemaMessage: str = "Schema not found"\n    selectionProperty: Optional[str] = None\n    isCustomOutputSchema: Optional[str] = None\n    allowCustomOutputSchema: bool = True\n    defaultCustomOutputSchema: bool = False\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return "Schema"\n\n    def kind(self) -> str:\n        return "PortSchema"\n\n    def bindSelectedFieldsProperty(self, property: str):\n        return replace(self, selectedFieldsProperty=property)\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindOnColumnClicked(self, callbackFunc):\n        return replace(self, onColumnClicked=callbackFunc)\n\n    def bindOnAllColumnsClicked(self, callbackFunc):\n        return replace(self, onAllColumnsClicked=callbackFunc)\n\n    def withRenamePortsEnabled(self, allowRename: Union[bool, str] = True):\n        return replace(self, allowRename=allowRename)\n\n    def withMinimumPorts(self, minNumberOfPorts: Union[int, str] = 0):\n        return replace(self, minPorts=minNumberOfPorts)\n\n    def withAddOrDeletePortsEnabled(self, allowAddDelete: Union[bool, str] = True):\n        return replace(self, allowAddOrDelete=allowAddDelete)\n\n    # The idea is that column-clicking can be allowed by\n    # either setting the allowSelectionFlag to true/false\n    # OR by setting the allowColumnSelectionProperty to a Property (a jsonpath in the component) which evaluates to\n    # either true or false\n    # eg, in simple components, you\'d know if you want to allow user to click or not on the column name in portschema\n    # but for something like aggregate, you may want to only allow it when the active tab is a specific tab\n    # The key idea is that only one of these should have a bool value, the other should be none\n    def asInput(self, allowSelectionFlag: Optional[bool] = None, allowColumnSelectionProperty: Optional[str] = None):\n        return replace(self,\n                       schemaType=PortSchemaTypeEnum.InputSchema,\n                       ports="component.ports.inputs",\n                       allowSelection=allowSelectionFlag,\n                       selectionProperty=allowColumnSelectionProperty,\n                       selectedFieldsProperty="component.ports.selectedInputFields",\n                       noSchemaMessage="Please connect input ports and fix upstream gems to see schema")\n\n    def asOutput(self):\n        return replace(self, schemaType=PortSchemaTypeEnum.OutputSchema, ports="component.ports.outputs",\n                       noSchemaMessage="Please fix gem errors and upstream gems to see schema",\n                       isCustomOutputSchema="component.ports.isCustomOutputSchema")\n\n    def jsonProperties(self) -> dict:\n        properties = super(PortSchema, self).jsonProperties()\n        properties["type"] = self.schemaType.value\n        properties["id"] = self.id\n        properties["noFieldsMessage"] = "Please connect port to see columns"\n        if (self.selectionProperty is not None):\n            properties["allowSelection"] = self.propertyPath(self.selectionProperty)\n        elif (self.allowSelection is not None):\n            properties["allowSelection"] = self.allowSelection\n\n        if isinstance(self.allowRename, bool):\n            properties["allowRename"] = self.allowRename\n        elif isinstance(self.allowRename, str):\n            properties["allowRename"] = self.propertyPath(self.allowRename)\n\n        if isinstance(self.minPorts, int):\n            properties["minPorts"] = self.minPorts\n        elif isinstance(self.minPorts, str):\n            properties["minPorts"] = self.propertyPath(self.minPorts)\n\n        if isinstance(self.allowAddOrDelete, bool):\n            properties["allowAddOrDelete"] = self.allowAddOrDelete\n        elif isinstance(self.allowAddOrDelete, str):\n            properties["allowAddOrDelete"] = self.propertyPath(self.allowAddOrDelete)\n\n        properties["noFieldsMessage"] = self.noSchemaMessage\n        if self.selectedFieldsProperty is not None:\n            properties["selectedFields"] = self.propertyPath(self.selectedFieldsProperty)\n        if self.ports is not None:\n            properties["ports"] = self.propertyPath(self.ports)\n        actions = list()\n        if self.onColumnClicked is not None:\n            actions.append("onColumnClick")\n        if self.onAllColumnsClicked is not None:\n            actions.append("onSelectAllColumns")\n        if self.isCustomOutputSchema is not None:\n            properties["isCustomOutputSchema"] = self.propertyPath(self.isCustomOutputSchema)\n        if len(actions) > 0:\n            properties["actions"] = actions\n        properties["allowCustomOutputSchema"] = self.allowCustomOutputSchema\n        properties["defaultCustomOutputSchema"] = self.defaultCustomOutputSchema\n        return properties\n\n\n@dataclass\nclass FileEditor(Atom):\n    newFileLanguage: Optional[str] = None\n    height: Optional[str] = "100%"\n    newFilePrefix: Optional[str] = "out"\n    propertyVar: Optional[str] = None\n    files: Optional[str] = None\n    minFiles: int = 0\n    allowRename: bool = False\n    allowAddOrDelete: bool = False\n    placeholder: dict = dict(),\n    ports: Optional[str] = None\n    mode: Optional[str] = "Normal"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return "FileEditor"\n\n    def kind(self) -> str:\n        return "FileEditor"\n\n    def propertyKey(self) -> str:\n        return "files"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withMinFiles(self, minFiles: int):\n        return replace(self, minFiles=minFiles)\n\n    def allowFileRenames(self):\n        return replace(self, allowRename=True)\n\n    def allowFileAddDelete(self):\n        return replace(self, allowAddOrDelete=True)\n\n    def withExpressionMode(self):\n        return replace(self, mode="Expression")\n\n    def bindPlaceholders(self, languagePlaceholders=None):\n        if languagePlaceholders is None:\n            languagePlaceholders = {\n                "scala": """concat(col("source_column"), col("other_column"))""",\n                "python": """concat(col("source_column"), col("other_column"))""",\n                "sql": """concat(source_column, other_column)"""}\n        return replace(self, placeholder=languagePlaceholders.copy())\n\n    def bindPorts(self, ports: str):\n        return replace(self, ports=ports)\n\n    def withSchemaSuggestions(self):\n        return self.bindPorts("component.ports.inputs")\n\n    def jsonProperties(self) -> dict:\n        properties = super(FileEditor, self).jsonProperties()\n\n        if self.newFilePrefix is not None:\n            properties["newFilePrefix"] = self.newFilePrefix\n\n        if self.newFileLanguage is not None:\n            properties["newFileLanguage"] = self.newFileLanguage\n\n        if self.height is not None:\n            properties["height"] = self.height\n\n        if self.minFiles is not None:\n            properties["minFiles"] = self.minFiles\n\n        if self.allowRename is not None:\n            properties["allowRename"] = self.allowRename\n\n        if self.allowAddOrDelete is not None:\n            properties["allowAddOrDelete"] = self.allowAddOrDelete\n\n        properties["placeholder"] = self.placeholder\n\n        if self.ports is not None:\n            properties["ports"] = self.propertyPath(self.ports)\n\n        if self.mode is not None:\n            properties["mode"] = self.mode\n\n        return properties\n\n\n@dataclass\nclass FileBrowser(Atom):\n    propertyVar: Optional[str] = None\n    showExecutionError: bool = True\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return "FileBrowser"\n\n    def kind(self) -> str:\n        return "FileBrowser"\n\n    def propertyKey(self) -> str:\n        return "path"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def hideExecutionErrors(self):\n        return replace(self, showExecutionError=False)\n\n    def jsonProperties(self) -> dict:\n        prop = super(FileBrowser, self).jsonProperties()\n        prop["showExecutionError"] = self.showExecutionError\n        return prop\n\n\n@dataclass\nclass HeaderText(Atom):\n    text: str\n\n    def kind(self) -> str:\n        return "Atoms.HeaderText"\n\n    def title(self) -> str:\n        return "HeaderText"\n\n    def property(self) -> Optional[str]:\n        return None\n\n    def bindProperty(self, property: str):\n        return self\n\n\n@dataclass\nclass SchemaEditor(Atom):\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return "SchemaEditor"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.SchemaEditor"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n\n@dataclass\nclass InferSchemaButton(Atom):\n    def title(self) -> str:\n        return "InferSchemaButton"\n\n    def kind(self) -> str:\n        return "Atoms.InferSchemaButton"\n\n    def property(self) -> Optional[str]:\n        return None\n\n    def bindProperty(self, property: str):\n        return self\n\n\n@dataclass\nclass PreviewDataButton(Atom):\n    def title(self) -> str:\n        return "PreviewDataButton"\n\n    def kind(self) -> str:\n        return "Atoms.PreviewDataButton"\n\n    def property(self) -> Optional[str]:\n        return None\n\n    def bindProperty(self, property: str):\n        return self\n\n\n@dataclass\nclass PreviewTable(Atom):\n    titleVar: str = "PreviewTable"\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def propertyKey(self) -> str:\n        return "schema"\n\n    def kind(self) -> str:\n        return "PreviewTable"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        return super(PreviewTable, self).jsonProperties()\n\n@dataclass\nclass Section(Atom):\n    borderColor: Optional[str] = None\n    thickness: Optional[str] = None\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return ""\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def kind(self) -> str:\n        return "Atoms.Section"\n\n    def withBorderColor(self, borderColor: str):\n        return replace(self, borderColor=borderColor)\n\n    def withThickness(self, thickness: str):\n        return replace(self, thickness=thickness)\n\n    def jsonProperties(self) -> dict:\n        properties = super(Section, self).jsonProperties()\n        if self.borderColor is not None:\n            properties["borderColor"] = self.borderColor\n        if self.thickness is not None:\n            properties["thickness"] = self.thickness\n        return properties\n\n@dataclass\nclass ConnectionResourceBrowser(Atom):\n    connectionId: str\n    databaseLabel: Optional[str] = None\n    schemaLabel: Optional[str] = None\n    tableLabel: Optional[str] = None\n    filePathLabel: Optional[str] = None\n    database: Optional[ConfigText] = None\n    schema: Optional[ConfigText] = None\n    table: Optional[ConfigText] = None\n    filePath: Optional[ConfigText] = None\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return "ConnectionResourceBrowser"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Atoms.ConnectionResourceBrowser"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withDatabase(self, element: ConfigText):\n        return replace(self, database=element)\n\n    def withSchema(self, element: ConfigText):\n        return replace(self, schema=element)\n\n    def withTable(self, element: ConfigText):\n        return replace(self, table=element)\n\n    def withFilePath(self, element: ConfigText):\n        return replace(self, filePath=element)\n\n    def jsonProperties(self) -> dict:\n        properties = super(ConnectionResourceBrowser, self).jsonProperties()\n        properties["connectionId"] = self.connectionId\n        if self.databaseLabel is not None:\n            properties["databaseLabel"] = self.databaseLabel\n        if self.schemaLabel is not None:\n            properties["schemaLabel"] = self.schemaLabel\n        if self.tableLabel is not None:\n            properties["tableLabel"] = self.tableLabel\n        if self.filePathLabel is not None:\n            properties["filePathLabel"] = self.filePathLabel\n        if self.database is not None:\n            properties["database"] = self.database.json()\n        if self.schema is not None:\n            properties["schema"] = self.schema.json()\n        if self.table is not None:\n            properties["table"] = self.table.json()\n        if self.filePath is not None:\n            properties["filePath"] = self.filePath.json()\n\n        return properties\n\n\'\'\' ------------------------------------ DIALOG -------------------------------------\'\'\'\n\n\nclass DialogElement(Element, ABC):\n    pass\n\n\n@dataclass\nclass DialogTitle(DialogElement, Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Dialogs.Title"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(DialogTitle, self).jsonProperties()\n        properties["title"] = self.propertyPath("component.metadata.label")\n        return properties\n\n\n@dataclass\nclass DialogContent(DialogElement, Container[Element]):\n    _children: list\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Dialogs.Content"\n\n\n@dataclass\nclass DialogFooter(DialogElement, Container[Element]):\n    _children: list = None\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Dialogs.Footer"\n\n\n@dataclass\nclass SubgraphDialogFooter(DialogElement, Container[Element]):\n    _children: list = None\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Atoms.SubgraphDialogFooter"\n\n\n@dataclass\nclass Dialog(Container[DialogElement]):\n    title: str\n    contentChildren: list = None\n    footer: Element = field(default_factory=DialogFooter)\n    copilot: Optional[CopilotSpec] = None\n\n    def kind(self) -> str:\n        return "Dialogs.Container"\n\n    def title(self) -> str:\n        return self.title\n\n    def children(self) -> list:\n        return [\n            self.footer,\n            DialogContent(self.contentChildren),\n            DialogTitle(self.title)\n        ]\n\n    def addElement(self, element: Element):\n        if self.contentChildren is None:\n            return replace(self, contentChildren=[element])\n        else:\n            self.contentChildren.insert(0, element)\n            return replace(self, contentChildren=self.contentChildren)\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        if self.copilot is not None:\n            props["copilot"] = self.copilot.json()\n        return props\n\n    def withCopilotEnabledAutoSuggestionProperties(self):\n        copilotSpec = CopilotSpec(method="copilot/suggestGemProperties", copilotProps=CopilotSpecProps()).withSuggestGemProperties().withAutoSuggestUpdate()\n        return replace(self, copilot=copilotSpec)\n\n\n\'\'\' ------------------------------------ DATASET DIALOG -----------------------------\'\'\'\n\n\n@dataclass\nclass DatasetDialogSection(Container[Element]):\n    title: str\n    spec: Optional[Element] = None\n\n    def kind(self) -> str:\n        return "DatasetDialogs.Section"\n\n    def children(self) -> list:\n        if self.spec is not None:\n            return [self.spec]\n        else:\n            return []\n\n    def jsonProperties(self) -> dict:\n        properties = super(DatasetDialogSection, self).jsonProperties()\n        if self.spec is not None:\n            properties["spec"] = self.spec.json()\n        return properties\n\n    def json(self) -> dict:\n        properties = self.jsonProperties()\n        properties["id"] = self.id\n        properties["title"] = self.title\n        return properties\n\n\n@dataclass\nclass DatasetDialog(Container[DatasetDialogSection]):\n    title: str\n    sections: list = None\n\n    def kind(self) -> str:\n        return "DatasetDialogs"\n\n    def children(self) -> list:\n        if self.sections is None:\n            return []\n        else:\n            return self.sections\n\n    def addSection(self, title: str, element: Element):\n        if self.sections is not None:\n            self.sections.append(DatasetDialogSection(title, element))\n            return replace(self, sections=self.sections)\n        else:\n            return replace(self, sections=[DatasetDialogSection(title, element)])\n\n\n\'\'\' ------------------------------------ TABS ----------------------------\'\'\'\n\n\n@dataclass\nclass TabPane(Container[Element]):\n    label: str\n    key: str\n    propertyVar: Optional[str] = None\n    _children: list = None\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Atoms.Tabs.TabPane"\n\n    def addElement(self, element: Element):\n        if self._children is None:\n            return replace(self, _children=[element])\n        else:\n            self._children.insert(0, element)\n            return replace(self, _children=self._children)\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        return {"tab": self.label, "key": self.key}\n\n\n@dataclass\nclass Tab(Container[Element]):\n    title: str\n    contentChildren: list = None\n\n    def children(self) -> list:\n        if self.contentChildren is None:\n            return []\n        else:\n            return self.contentChildren\n\n    def kind(self) -> str:\n        return "Tabs.Tab"\n\n    def addElement(self, element: Element):\n        if self.contentChildren is None:\n            return replace(self, contentChildren=[element])\n        else:\n            self.contentChildren.insert(0, element)\n            return replace(self, contentChildren=self.contentChildren)\n\n\n@dataclass\nclass SubgraphConfigurationTabs(Container[TabPane]):\n    propertyVar: Optional[str] = None\n    tabs: list = None\n    childrenList: list = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def children(self) -> list:\n        if self.childrenList is None:\n            return []\n        else:\n            return self.childrenList\n\n    def addTabPane(self, tab: TabPane):\n        if self.tabs is None:\n            return replace(self, tabs=[tab])\n        else:\n            self.tabs.insert(0, tab)\n        return replace(self, tabs=self.tabs)\n\n    def kind(self) -> str:\n        return "Atoms.SubgraphConfigurationTabs"\n\n    def jsonProperties(self) -> dict:\n        tab_jsons = []\n        tabs = self.tabs if self.tabs is not None else []\n        for tab in reversed(tabs):\n            tab_jsons.append(tab.json())\n        return {"tabs": tab_jsons}\n\n\n@dataclass\nclass Tabs(Container[TabPane]):\n    propertyVar: Optional[str] = None\n    childrenList: list = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def children(self) -> list:\n        if self.childrenList is None:\n            return []\n        else:\n            return self.childrenList\n\n    def kind(self) -> str:\n        return "Atoms.Tabs"\n\n    def addTabPane(self, tab: TabPane):\n        if self.childrenList is None:\n            return replace(self, childrenList=[tab])\n        else:\n            self.childrenList.insert(0, tab)\n        return replace(self, childrenList=self.childrenList)\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        if self.propertyVar is None:\n            return {}\n        else:\n            return {"activeKey": self.propertyPath(self.propertyVar)}\n\n\n@dataclass\nclass PortSchemaTabs(Container[TabPane]):\n    selectedFieldsProperty: Optional[str] = None\n    property: Optional[str] = None\n    minNumberOfPorts: Union[int, str] = 0\n    editableInput: Union[Optional[bool], str] = None\n    allowSelection: bool = False\n    singleColumnClickCallback: Optional = None\n    childrenList: list = None\n    allowInportRename: Union[bool, str] = False\n    allColumnsSelectionCallback: Optional = None\n    allowInportAddDelete: Union[bool, str] = False\n    allowOutportRename: Union[bool, str] = False\n    editableOutput: Union[Optional[bool], str] = None\n    allowOutportAddDelete: Union[bool, str] = False\n    selectionProperty: Optional[str] = None\n    minNumberOfOutPorts: Union[str, Optional[int]] = None\n\n    def allowColumnClickBasedOn(self, propertyPath: str):\n        return replace(self, selectionProperty=(propertyPath))\n\n    def getPortSchema(self) -> PortSchema:\n        # propertyPath should bind to a bool property.\n        # If the value at propertyPath is true, then user would be able to click on column names,\n        # else this decision would be taken based on whether callbacks are defined.\n        # If yes, allow clicking, else no\n        if (self.selectionProperty is not None):\n            ip0 = PortSchema(propertyVar=self.property).asInput(\n                allowColumnSelectionProperty=self.selectionProperty).withMinimumPorts(self.minNumberOfPorts)\n        else:\n            isSelectionAllowed = (self.singleColumnClickCallback is not None) or (\n                    self.allColumnsSelectionCallback is not None)\n            ip0 = PortSchema(propertyVar=self.property).asInput(isSelectionAllowed).withMinimumPorts(\n                self.minNumberOfPorts)\n\n        if self.editableInput is None:\n            ip1 = ip0 \\\n                .withRenamePortsEnabled(self.allowInportRename) \\\n                .withAddOrDeletePortsEnabled(self.allowInportAddDelete)\n        else:\n            ip1 = ip0.withRenamePortsEnabled(self.editableInput).withAddOrDeletePortsEnabled(self.editableInput)\n\n        ip2 = ip1.bindSelectedFieldsProperty(\n            self.selectedFieldsProperty) if self.selectedFieldsProperty is not None else ip1\n        ip3 = ip2.bindOnColumnClicked(\n            self.singleColumnClickCallback) if self.singleColumnClickCallback is not None else ip2\n        inputPortSchema = ip3.bindOnAllColumnsClicked(\n            self.allColumnsSelectionCallback) if self.allColumnsSelectionCallback is not None else ip3\n        return inputPortSchema\n\n    def getOutputPortSchema(self) -> PortSchema:\n        op0: PortSchema = PortSchema(allowSelection=self.allowSelection, propertyVar=self.property).asOutput()\n        if self.editableOutput is None:\n            op = op0 \\\n                .withRenamePortsEnabled(self.allowOutportRename) \\\n                .withAddOrDeletePortsEnabled(self.allowOutportAddDelete)\n        else:\n            op = op0.withRenamePortsEnabled(self.editableOutput).withAddOrDeletePortsEnabled(self.editableOutput)\n        if self.minNumberOfOutPorts is not None:\n            op = op.withMinimumPorts(self.minNumberOfOutPorts)\n        return op\n\n    def kind(self) -> str:\n        return "Atoms.Tabs"\n\n    def children(self) -> list:\n        if self.childrenList is None:\n            return []\n        else:\n            return self.childrenList\n\n    def importSchema(self) -> Tabs:\n        inputPortSchema = self.getPortSchema()\n        outputPortSchema = self.getOutputPortSchema()\n        return Tabs(). \\\n            addTabPane(TabPane("Input", "Input").addElement(inputPortSchema)). \\\n            addTabPane(TabPane("Output", "Output").addElement(outputPortSchema))\n\n\n\'\'\' ------------------------------------ TABLE ----------------------------\'\'\'\n\n\n@dataclass\nclass TableColumn(Container[Element]):\n    title: str\n    element: Element\n\n    def kind(self) -> str:\n        return "Tables.Column"\n\n    def children(self) -> list:\n        return [self.element]\n\n    def jsonProperties(self) -> dict:\n        return {"title": self.title}\n\n\n\'\'\' ------------------------------ EXPRESSION TABLE ---------------------------------\'\'\'\n\n\n@dataclass\nclass Column:\n    label: str\n    key: str\n    component: Optional[Element] = None\n    width: str = "1fr"\n    id: str = ""\n    align: Optional[str] = None\n\n    def __post_init__(self):\n        self.id = f"{UISpec().getId()}"\n\n    def json(self):\n        props = dict()\n        props["label"] = self.label\n        props["key"] = self.key\n        props["width"] = self.width\n        if self.component is not None:\n            props["component"] = self.component.json()\n        if self.align is not None:\n            props["align"] = self.align\n        return props\n\n\n@dataclass(frozen=True)\nclass SColumn:\n    rawExpression: str\n    format: str = "python"\n    expression: Optional[sparkColumn] = None\n    usedColumns: List[str] = field(default_factory=list)\n    diagnosticMessages: Optional[List[str]] = None\n\n    @staticmethod\n    def getSColumn(column: str, format: str = "python"):\n        return SColumn(f\'col("{column}")\', format, col(column), [column])\n\n    def isExpressionPresent(self) -> bool:\n        return len(self.rawExpression.strip()) != 0\n\n    def isValidSparkExpression(self) -> bool:\n        return self.expression is not None\n\n    def column(self) -> sparkColumn:\n        return self.expression\n\n    def columnName(self) -> str:\n        return self.expression._jc.toString()\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        props["format"] = format\n        props["expression"] = self.rawExpression if self.isExpressionPresent() else ""\n        return props\n\n    def __eq__(self, other) -> bool:\n        return self.jsonProperties() == other.jsonProperties()\n\n\n@dataclass(frozen=True)\nclass SColumnExpression:\n    target: str\n    expression: SColumn\n    description: str = ""\n    _row_id: Optional[str] = None\n\n    @staticmethod\n    def getSColumnExpression(column: str):\n        # todo @ank sanitize the column for backticks here\n        return SColumnExpression(column, SColumn.getSColumn(column), "")\n\n    @staticmethod\n    def getColumnsFromColumnExpressionList(columnExpressions: list) -> List[sparkColumn]:\n        columnList = []\n        for expression in columnExpressions:\n            columnList.append(expression.expression.expression)\n        return columnList\n\n    def withRowId(self):\n        if self._row_id is not None and len(self._row_id.strip()) > 0:\n            return self\n        else:\n            from datetime import datetime\n            import random\n            return replace(self, _row_id=(\n                    datetime.now().isoformat() + "_" + str(random.getrandbits(32))).__hash__().__abs__().__str__())\n\n    def column(self) -> sparkColumn:\n        return self.expression.expression.alias(self.target)\n\n    def isExpressionPresent(self) -> bool:\n        return self.expression.isExpressionPresent()\n\n    def isValidSparkExpression(self) -> bool:\n        return self.expression.isValidSparkExpression()\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        props["target"] = self.target\n        expression = dict()\n        # The format key is not present in the Python world\'s implementation of SColumn.\n        # However, Scala implementation uses it, so setting it here. It\'ll be used for understanding of the newRowData by ui.\n        # Hardcoding its value to scala for letting dialog-jsons be the same and therefore tests to pass.\n        expression["format"] = "scala"\n        expression["expression"] = self.expression.rawExpression if self.isExpressionPresent() else ""\n        props["expression"] = expression\n        props["description"] = self.description\n        return props\n\n\nclass SecretValuePart(ABC):\n    @abstractmethod\n    def jsonProperties(self):\n        pass\n\n    @staticmethod\n    def fromJson(obj):\n        type = obj["type"]\n        if type == "pipelineConfiguration":\n            return ConfigSecret(obj[\'value\'])\n        elif type == "literal":\n            return TextSecret(obj[\'value\'])\n        elif type == "vaultSecret":\n            value = obj[\'value\']\n            return VaultSecret(value[\'providerType\'], value[\'providerName\'], value[\'providerId\'],\n                               value.get(\'secretScope\'), value[\'secretKey\'])\n        else:\n            raise Exception("Invalid type of SecretValue: " + type)\n\n    @staticmethod\n    def convertTextToSecret(value: str) -> list:\n        def convertTextToSecretInternal(value: str) -> list:\n            import re, itertools\n            configPattern = "\\\\$\\\\{[^\\\\{\\\\}]*\\\\}"\n            configParts = [ConfigSecret(x[2:-1].split(".")) for x in re.findall(configPattern, value)]\n            textParts = [TextSecret(x) if x else None for x in re.split(configPattern, value)]\n            return [item for tup in itertools.zip_longest(textParts, configParts) for item in tup if item]\n\n        return [x for v in value.split("$$") for x in convertTextToSecretInternal(v) + [TextSecret("$")]][:-1]\n\n\n@dataclass(frozen=True)\nclass SecretValue:\n    parts: list\n\n    def jsonProperties(self) -> list:\n        return [part.jsonProperties() for part in self.parts]\n\n    @staticmethod\n    def fromJson(obj):\n        return SecretValue([SecretValuePart.fromJson(part) for part in obj])\n\n\n@dataclass(frozen=True)\nclass TextSecret(SecretValuePart):\n    value: str\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        props["type"] = "literal"\n        props["value"] = self.value\n        return props\n\n\n@dataclass(frozen=True)\nclass ConfigSecret(SecretValuePart):\n    value: list\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        props["type"] = "pipelineConfiguration"\n        props["value"] = self.value\n        return props\n\n\n@dataclass(frozen=True)\nclass VaultSecret(SecretValuePart):\n    providerType: str\n    providerName: str\n    providerId: str\n    secretScope: Optional[str]\n    secretKey: str\n\n    def jsonProperties(self) -> dict:\n        props = dict()\n        props["type"] = "vaultSecret"\n        value = dict()\n        value["providerType"] = self.providerType\n        value["providerName"] = self.providerName\n        value["providerId"] = self.providerId\n        if self.secretScope is not None:\n            value["secretScope"] = self.secretScope\n        value["secretKey"] = self.secretKey\n        props["value"] = value\n        return props\n\n\n@dataclass\nclass BasicTable(Atom):\n    titleVar: str\n    targetColumnKey: Optional[str] = None\n    propertyVar: Optional[str] = None\n    columns: List[Column] = None\n    delete: bool = True\n    height: Optional[str] = None\n    footer: List[Element] = field(default_factory=list)\n    appendNewRow: bool = True\n    emptyText: Optional[str] = None\n    newRowData: Optional[dict] = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def propertyKey(self) -> str:\n        return "data"\n\n    def kind(self) -> str:\n        return "Atoms.Table"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def addFooter(self, element: Element):\n        if self.footer is None:\n            return replace(self, footer=[element])\n        else:\n            self.footer.insert(0, element)\n            return replace(self, footer=self.footer)\n\n    def getTemplateElements(self):\n        return self.footer\n\n    def setEmptyContainerText(self, text: str):\n        return replace(self, emptyText=text)\n\n    def addColumn(self, col: Column):\n        if self.columns is None:\n            return replace(self, columns=[col])\n        else:\n            self.columns.insert(0, col)\n            return replace(self, columns=self.columns)\n\n    def setTargetColumn(self, columnName):\n        self.targetColumnKey = columnName\n\n    def jsonProperties(self) -> dict:\n        props = super(BasicTable, self).jsonProperties()\n        colJsons = []\n        for col in self.columns:\n            colJsons.append(col.json())\n        if len(self.columns) > 0 and self.delete:\n            colJsons.append({"type": "delete"})\n        if self.height is not None:\n            props["height"] = self.height\n        footerJsons = []\n        for footer in self.footer:\n            footerJsons.append(footer.json())\n        if self.emptyText is not None:\n            props["emptyText"] = self.emptyText\n        props["newRowData"] = self.newRowData\n        props["appendNewRow"] = self.appendNewRow\n        props["footer"] = footerJsons\n        props["columns"] = colJsons\n        if self.targetColumnKey is not None:\n            props["targetColumnKey"] = self.targetColumnKey\n        return props\n\n@dataclass\nclass CodeTable(Atom):\n    titleVar: str\n    targetColumn: Optional[Column] = None\n    expressionColumn: Column = field(default_factory=lambda: Column("Expression", "expression.expression", ExpressionBox(ignoreTitle=True).bindPlaceholders().withSchemaSuggestions()))\n    propertyVar: Optional[str] = None\n    delete: bool = False\n    height: Optional[str] = None\n    footer: List[Element] = field(default_factory=list)\n    newRowData: Any = None\n    appendNewRow: bool = True\n    virtualize: Optional[bool] = None\n    targetColumnKey: Optional[str] = None\n    delay: Optional[int] = None\n    newRowLabel: Optional[RowLabel] = None\n    visualBuilder: Optional[VisualBuilderSpec] = None\n    placeholderRows: Optional[int] = None\n    fixedHeader: Optional[bool] = None\n    selectMode: Optional[SelectMode] = SelectMode.always\n    collapsible: Optional[bool] = None\n    rowDetailsTemplate: List[Element] = field(default_factory=list)\n    allowConditions: Optional[bool] = None\n    allowLoops: Optional[bool] = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return "Atoms.CodeTable"\n\n    def propertyKey(self) -> str:\n        return "data"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def setTargetColumnKey(self, columnName: str):\n        return replace(self, targetColumnKey=columnName)\n\n    def withSchemaSuggestions(self):\n        currentExpressionBox = self.expressionColumn.component.withSchemaSuggestions()\n        return replace(self, expressionColumn=replace(self.expressionColumn, component=currentExpressionBox))\n\n    def withRowId(self):\n        return replace(self, virtualize=True)\n\n    def withNewRowData(self, data: Any):\n        return replace(self, newRowData=data)\n\n    def columns(self) -> List[Column]:\n        return [col for col in [self.targetColumn, self.expressionColumn] if col is not None]\n\n    def addFooter(self, element: Any):\n        return replace(self, footer=[element] + self.footer)\n\n    def getTemplateElements(self) -> List[Any]:\n        return self.footer + self.rowDetailsTemplate\n\n    def addRowDetail(self, element: Any):\n        return replace(self, rowDetailsTemplate=[element] + self.rowDetailsTemplate)\n\n    def withDelay(self, delay: int):\n        return replace(self, delay=delay)\n\n    def withPlaceholderRows(self, placeholderRows: int):\n        return replace(self, placeholderRows=placeholderRows)\n\n    def withFixedHeader(self, fixedHeader: bool):\n        return replace(self, fixedHeader=fixedHeader)\n\n    def withLabel(self, label: RowLabel):\n        return replace(self, newRowLabel=label)\n\n    def withSelectMode(self, mode: SelectMode):\n        return replace(self, selectMode=mode)\n\n    def withCollapsible(self, value: bool):\n        return replace(self, collapsible=value)\n\n    def withAllowLoops(self, value: bool):\n        return replace(self, allowLoops=value)\n\n    def withAllowConditions(self, value: bool):\n        return replace(self, allowConditions=value)\n\n    def withVisualBuilderSpec(self, visualBuilder: VisualBuilderSpec):\n        return replace(self, visualBuilder=visualBuilder)\n\n    def withExpressionBuilder(self, visualBuilderType: List[ExpressionBuilderType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedTypes=visualBuilderType))\n\n    def withUnsupportedExpressionBuilderTypes(self, unsupportedTypes: List[ExpressionBuilderType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   unsupportedTypes=unsupportedTypes))\n\n    def withGroupBuilder(self, groupBuilderType: GroupBuilderType):\n        return replace(self,\n                       visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), builderType=groupBuilderType))\n\n    def withBlockType(self, expressionBlockType: ExpressionBlockType):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedBlockType=expressionBlockType))\n\n    def withValueType(self, valueType: ExpressionValueType):\n        return replace(self,\n                       visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), supportedValueType=valueType))\n\n    def withFunctionTypes(self, functionTypes: List[ExpressionFunctionType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedFunctionTypes=functionTypes))\n\n    def withConfigTypes(self, configTypes: List[ExpressionConfigType]):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(),\n                                                   supportedConfigTypes=configTypes))\n\n    def withBorder(self, border: bool):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), border=border))\n\n    def withVisualPlaceholder(self, placeholder: str):\n        return replace(self, visualBuilder=replace(self.visualBuilder or VisualBuilderSpec(), placeholder=placeholder))\n\n    def jsonProperties(self) -> Dict[str, Any]:\n        props = super().jsonProperties()\n        if hasattr(super(), "jsonProperties"):\n            props.update(super().jsonProperties())\n        props["newRowData"] = self.newRowData\n        props["appendNewRow"] = self.appendNewRow\n        colJsons = [column.json() for column in self.columns()]\n        colsWithDelete = colJsons\n        if len(colJsons) > 0 and self.delete:\n            colsWithDelete = colJsons.append({"type": "delete"})\n        props["columns"] = colsWithDelete\n        props["footer"] = [footer.json() for footer in self.footer]\n        if not self.targetColumnKey:\n            if self.targetColumn:\n                props["targetColumnKey"] = self.targetColumn.key\n        else:\n            props["targetColumnKey"] = self.targetColumnKey\n        if self.newRowLabel is not None:\n            props["newRowLabel"] = self.newRowLabel.value\n        if self.selectMode is not None:\n            props["selectMode"] = self.selectMode.value\n        if self.collapsible is not None:\n            props["collapsible"] = self.collapsible\n        if self.height is not None:\n            props["height"] = self.height\n        if self.virtualize is not None:\n            props["virtualize"] = self.virtualize\n        if self.delay is not None:\n            props["delay"] = self.delay\n        if self.placeholderRows is not None:\n            props["placeholderRows"] = self.placeholderRows\n        if self.fixedHeader is not None:\n            props["fixedHeader"] = self.fixedHeader\n        if self.visualBuilder is not None:\n            props["visualBuilder"] = self.visualBuilder.json()\n        if self.allowConditions is not None:\n            props["allowConditions"] = self.allowConditions\n        if self.allowLoops is not None:\n            props["allowLoops"] = self.allowLoops\n        props["rowDetailsTemplate"] = [temp.json() for temp in self.rowDetailsTemplate]\n        return props\n\n\n@dataclass\nclass ExpTable(Atom):\n    titleVar: str\n    targetColumn: Column = field(\n        default_factory=lambda: Column("Target Column", "target", TextBox("", ignoreTitle=True), width="30%"))\n    expressionColumn: Column = field(default_factory=lambda: Column("Expression", "expression.expression",\n                                                                    ExpressionBox(\n                                                                        ignoreTitle=True).bindPlaceholders().withSchemaSuggestions()))\n    propertyVar: Optional[str] = None\n    delete: bool = True\n    virtualize: Optional[bool] = None\n    newRowData: Optional[dict] = None\n    appendNewRow: bool = True\n    height: Optional[str] = None\n    footer: List[Element] = field(default_factory=list)\n    targetColumnKey: Optional[str] = "target"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def setTargetColumn(self, columnName):\n        self.targetColumnKey = columnName\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return "Atoms.Table"\n\n    def bindPropertyKey(self) -> str:\n        return "data"\n\n    def propertyKey(self) -> str:\n        return "data"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def enableVirtualization(self):\n        return replace(self, virtualize=True)\n\n    def columns(self) -> list:\n        return [self.targetColumn, self.expressionColumn]\n\n    def addFooter(self, element: Element):\n        if self.footer is None:\n            return replace(self, footer=[element])\n        else:\n            self.footer.insert(0, element)\n            return replace(self, footer=self.footer)\n\n\n    def withCopilotEnabledExpressions(self, copilot: CopilotSpec = None):\n        if self.expressionColumn.component is not None and isinstance(self.expressionColumn.component, ExpressionBox):\n            new_expression_col = replace(\n                self.expressionColumn,\n                component=self.expressionColumn.component.withCopilotEnabledExpression()\n            )\n            return replace(self, expressionColumn=new_expression_col)\n        else:\n            return self\n\n    def allowCopilotExpressionsFix(self):\n        if self.expressionColumn.component is not None and isinstance(self.expressionColumn.component, ExpressionBox):\n            new_expression_col = replace(\n                self.expressionColumn,\n                component=self.expressionColumn.component.allowFixWithCopilot()\n            )\n            return replace(self, expressionColumn=new_expression_col)\n        else:\n            return self\n\n    def jsonProperties(self) -> dict:\n        props = super().jsonProperties()\n        colJsons = []\n        for col in self.columns():\n            colJsons.append(col.json())\n        if len(self.columns()) > 0 and self.delete:\n            colJsons.append({"type": "delete"})\n        if self.virtualize is not None:\n            props["virtualize"] = self.virtualize\n        props["newRowData"] = self.newRowData\n        if self.height is not None:\n            props["height"] = self.height\n        footerJsons = []\n        for footer in self.footer:\n            footerJsons.append(footer.json())\n        props["footer"] = footerJsons\n        props["appendNewRow"] = self.appendNewRow\n        props["columns"] = colJsons\n        if self.targetColumnKey is not None:\n            props["targetColumnKey"] = self.targetColumnKey\n        else:\n            props["targetColumnKey"] = self.targetColumn.key\n        return props\n\n\n@dataclass\nclass ConfigurationSelectorTable(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    footer: List[Element] = field(default_factory=list)\n    availableConfigFieldNames: Optional[str] = None\n    availableColumnNames: Optional[str] = None\n    portIndex: Optional[str] = None\n    newRowData: Optional[dict] = None\n    appendNewRow: bool = True\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def setTargetColumn(self, columnName):\n        self.targetColumnKey = columnName\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return "Atoms.ConfigurationSelectorTable"\n\n    def propertyKey(self) -> str:\n        return "data"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def addFooter(self, element: Element):\n        if self.footer is None:\n            return replace(self, footer=[element])\n        else:\n            self.footer.insert(0, element)\n            return replace(self, footer=self.footer)\n\n    def bindConfigFieldNames(self, property: str):\n        return replace(self, availableConfigFieldNames=property)\n\n    def bindColumnNames(self, property: str):\n        return replace(self, availableColumnNames=property)\n\n    def bindPortIndex(self, property: str):\n        return replace(self, portIndex=property)\n\n    def jsonProperties(self) -> dict:\n        props = super().jsonProperties()\n        props["newRowData"] = self.newRowData\n        footerJsons = []\n        for footer in self.footer:\n            footerJsons.append(footer.json())\n        props["footer"] = footerJsons\n        props["appendNewRow"] = self.appendNewRow\n        props["portIndex"] = self.portIndex\n        props["availableConfigFieldNames"] = self.availableConfigFieldNames\n        props["availableColumnNames"] = self.availableColumnNames\n        return props\n\n\n@dataclass\nclass KeyValuePair(Atom):\n    key: str\n    value: str\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return ""\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.KeyValuePair"\n\n    def jsonProperties(self) -> dict:\n        props = super().jsonProperties()\n        props[\'key\'] = self.key\n        props[\'value\'] = self.value\n        return props\n\n\n@dataclass\nclass KeyValuePairs(Atom):\n    titleVar: str = ""\n    propertyVar: Optional[str] = None\n    disabled: bool = False\n    readOnly: bool = False\n    placeholder: KeyValuePair = None\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return "Atoms.KeyValuePairs"\n\n    def propertyKey(self) -> str:\n        return "pairs"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def isReadOnly(self, readOnly: bool = True):\n        return replace(self, readOnly=readOnly)\n\n    def isDisabled(self, disabled: bool = True):\n        return replace(self, disabled=disabled)\n\n    def setPlaceholder(self, keyValuePair: KeyValuePair):\n        return replace(self, placeholder=keyValuePair)\n\n    def jsonProperties(self) -> dict:\n        props = super().jsonProperties()\n        props[\'disabled\'] = self.disabled\n        props[\'readOnly\'] = self.readOnly\n        props[\'placeholder\'] = self.placeholder.jsonProperties()\n        return props\n\n\n\'\'\' ------------------------------ LAYOUTS ---------------------------------\'\'\'\n\n\n@dataclass\nclass StackLayout(Container[Element]):\n    gap: Optional[str] = "1rem"\n    direction: Optional[str] = None\n    align: Optional[str] = None\n    width: Optional[str] = None\n    alignY: Optional[str] = None\n    height: Optional[str] = None\n    _children: list = None\n    padding: Optional[str] = None\n    style: Optional[dict] = None\n    _template: Optional[Element] = None\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Layouts.Stack"\n\n    def addElement(self, child: Element):\n        if child is None:\n            return self\n        elif self._children is None:\n            return replace(self, _children=[child])\n        else:\n            self._children.insert(0, child)\n            return replace(self, _children=self._children)\n\n    def addTemplate(self, template: Element):\n        return replace(self, _template=template)\n\n    def template(self) -> Optional[Element]:\n        return self._template\n\n    def jsonProperties(self) -> dict:\n        properties = dict()\n        if self.gap is not None:\n            properties["gap"] = self.gap\n        if self.direction is not None:\n            properties["direction"] = self.direction\n        if self.alignY is not None:\n            properties["alignY"] = self.alignY\n        if self.align is not None:\n            properties["align"] = self.align\n        if self.width is not None:\n            properties["width"] = self.width\n        if self.height is not None:\n            properties["height"] = self.height\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.padding is not None:\n            properties["padding"] = self.padding\n        if self._template is not None:\n            properties["template"] = self.template().json()\n        return properties\n\n\n@dataclass\nclass ColumnLayout(Container[Element]):\n    width: str = "1fr"\n    childrenList: list = None\n    overflow: Optional[str] = None\n    style: Optional[dict] = None\n    padding: Optional[str] = None\n\n    def children(self) -> list:\n        if self.childrenList is None:\n            return []\n        else:\n            return self.childrenList\n\n    def kind(self) -> str:\n        return "Layouts.Columns.Column"\n\n    def addElement(self, child: Element):\n        if self.childrenList is None:\n            return replace(self, childrenList=[child])\n        else:\n            self.childrenList.insert(0, child)\n            return replace(self, childrenList=self.childrenList)\n\n    def jsonProperties(self) -> dict:\n        properties = dict()\n        properties["width"] = self.width\n        if self.overflow is not None:\n            properties["overflow"] = self.overflow\n        if self.style is not None:\n            properties["style"] = self.style\n        if self.padding is not None:\n            properties["padding"] = self.padding\n        return properties\n\n\n@dataclass\nclass ColumnsLayout(Container[Element]):\n    gap: Optional[str] = None\n    alignY: Optional[str] = None\n    height: Optional[str] = None\n    _children: list = None\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def kind(self) -> str:\n        return "Layouts.Columns"\n\n    def addColumn(self, column: Optional[Element] = None, width: str = "1fr", overflow: Optional[str] = None):\n        if column is not None:\n            return self.addElement(ColumnLayout(width, [column], overflow))\n        else:\n            return self.addElement(ColumnLayout(width, None, overflow))\n\n    def addElement(self, child: Element):\n        if self._children is None:\n            return replace(self, _children=[child])\n        else:\n            self._children.insert(0, child)\n            return replace(self, _children=self._children)\n\n    def jsonProperties(self) -> dict:\n        properties = dict()\n        if self.gap is not None:\n            properties["gap"] = self.gap\n        if self.alignY is not None:\n            properties["alignY"] = self.alignY\n        if self.height is not None:\n            properties["height"] = self.height\n        return properties\n\n\n@dataclass\nclass SimpleButtonLayout(Container[Element]):\n    label: str\n    onClick: Optional = None\n    _children: list = None\n    stackLayout: Optional[StackLayout] = None\n\n    # @staticmethod\n    def __new__(cls, label: str, onClickFunc: Optional = None):\n        primaryButton: Button = Button(label, _children=[NativeText(label)])\n        buttonWithCB = replace(primaryButton, onClick=onClickFunc) if onClickFunc is not None else primaryButton\n        return StackLayout(alignY="start").addElement(buttonWithCB)\n\n    def kind(self) -> str:\n        return "Layouts.Stack"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def jsonProperties(self) -> dict:\n        properties = super(SimpleButtonLayout, self).jsonProperties()\n        if self.onClick is not None:\n            properties["actions"] = ["onButtonClick"]\n        return properties\n\n\n@dataclass\nclass Card(Container[Element]):\n    header: Optional[Element] = None\n    collapsible: Optional[bool] = None\n    collapsed: Optional[bool] = None\n    _children: list = None\n\n    def kind(self) -> str:\n        return "Atoms.Card"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def addElement(self, child: Element):\n        if self._children is None:\n            return replace(self, _children=[child])\n        else:\n            self._children.insert(0, child)\n            return replace(self, _children=self._children)\n\n    def jsonProperties(self) -> dict:\n        properties = dict()\n        if self.header is not None:\n            properties["header"] = self.header.json()\n        if self.collapsible is not None:\n            properties["collapsible"] = self.collapsible\n        if self.collapsed is not None:\n            properties["collapsed"] = self.collapsed\n        properties["actions"] = list()  # sending empty actions as these are derived from UI element\n        return properties\n\n\n\'\'\' ------------------------------ LISTS ---------------------------------\'\'\'\n\n\n@dataclass\nclass ListItemDelete(Atom):\n    titleVar: str\n    rowIdentifier: Optional[str] = "record"\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return "Atoms.ListRowDeleteButton"\n\n    def property(self) -> Optional[str]:\n        return None\n\n    def bindProperty(self, property: str):\n        return self\n\n    def jsonProperties(self) -> dict:\n        properties = super(ListItemDelete, self).jsonProperties()\n        if self.rowIdentifier is not None:\n            properties["rowIdentifier"] = self.rowIdentifier\n        return properties\n\n\n@dataclass\nclass OrderedList(Atom):\n    titleVar: str\n    rowTemplate: list = None\n    propertyVar: Optional[str] = None\n    emptyText: Optional[str] = None\n    virtualize: Optional[bool] = None\n\n    def rowIdentifier(self):\n        return "record"\n\n    def propertyKey(self) -> str:\n        return "data"\n\n    def addElement(self, element: Element):\n        if self.rowTemplate is None:\n            return replace(self, rowTemplate=[element])\n        else:\n            self.rowTemplate.insert(0, element)\n            return replace(self, rowTemplate=self.rowTemplate)\n\n    def enableVirtualization(self):\n        return replace(self, virtualize=True)\n\n    def setEmptyContainerText(self, text: str):\n        return replace(self, emptyText=text)\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.List"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(OrderedList, self).jsonProperties()\n        properties["rowIdentifier"] = self.rowIdentifier()\n        properties["emptyText"] = self.emptyText\n        if self.virtualize is not None:\n            properties["virtualize"] = self.virtualize\n        rows = []\n        for row in self.rowTemplate:\n            rows.append(row.json())\n        properties["rowTemplate"] = rows\n        return properties\n\n\n\'\'\' ------------------------------ ENUMS ---------------------------------\'\'\'\n\n\n@dataclass\nclass EnumOption(Container[Element]):\n    title: str\n    element: Optional[Element] = None\n\n    def kind(self) -> str:\n        return "Enum.Option"\n\n    def withElement(self, element: Element):\n        return replace(self, element=element)\n\n    def children(self) -> list:\n        return [self.element]\n\n    def jsonProperties(self) -> dict:\n        return {"title": self.title}\n\n\n@dataclass\nclass Enum(Container[EnumOption]):\n    options: list = None\n\n    def kind(self) -> str:\n        return "Enum.Container"\n\n    def addOption(self, option: EnumOption):\n        if self.options is None:\n            return replace(self, options=[option])\n        else:\n            self.options.insert(0, option)\n            return replace(self, options=self.options)\n\n    def children(self) -> list:\n        return self.options\n\n\n\'\'\' ------------------------------ Others ---------------------------------\'\'\'\n\n\n@dataclass\nclass Text(Container[Element]):\n    type: str = "default"\n    property: Optional[str] = None\n    _children: list = None\n    level: Optional[FontLevel] = None\n    tooltip: Optional[str] = None\n\n    def kind(self) -> str:\n        return "Atoms.Text"\n\n    def children(self) -> list:\n        return self._children\n\n    def addElement(self, child: Element):\n        if self._children is None:\n            return replace(self, _children=[child])\n        else:\n            self._children.insert(0, child)\n            return replace(self, _children=self._children)\n\n    def addToolTip(self, msg:str):\n        return replace(self, tooltip=msg)\n\n    def jsonProperties(self) -> dict:\n        properties = dict()\n        properties["type"] = self.type\n        if self.level is not None:\n            properties["level"] = self.level.value\n\n        if self.tooltip is not None:\n            properties["tooltip"] = self.tooltip\n\n        return properties\n\n\nclass Expr(ABC):\n    @abstractmethod\n    def json(self):\n        pass\n\n    def propertyPathExpr(self, context: PropertyContext):\n        return self.json()\n\n\n@dataclass\nclass PropExpr(Expr):\n    value: str\n\n    def json(self):\n        return f"${{self.value}}"\n\n    def propertyPathExpr(self, context: PropertyContext):\n        property = self.value\n\n        if (property.startswith("component.properties") and (context.prefix != "")):\n            propName = property[:len("component.properties.")]\n            return (f"${{component.properties.{context.prefix}.{propName}}}")\n        else:\n            return (f"${{{property}}}")\n\n\n@dataclass\nclass StringExpr(Expr):\n    value: str\n\n    def json(self):\n        return self.value\n\n\n@dataclass\nclass BooleanExpr(Expr):\n    value: bool\n\n    def json(self):\n        return self.value\n\n\n@dataclass\nclass Condition(Atom):\n    leftProp: Optional[Expr] = None\n    rightProp: Optional[Expr] = None\n    propertyVar: Optional[str] = None\n    consequent: List[Element] = field(default_factory=list)\n    alternate: List[Element] = field(default_factory=list)\n    condition: str = "Exists"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return "Condition"\n\n    def kind(self) -> str:\n        return "Condition"\n\n    def getTemplateElements(self):\n        return self.consequent + self.alternate\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    conditionSpecifics = {\n        "Exists": {"operator": "Unary", "leftKey": "test", "rightKey": ""},\n        "InList": {"operator": "PresentInList", "leftKey": "test_value", "rightKey": "test_list"},\n        "Equal": {"operator": "Equal", "leftKey": "test_left", "rightKey": "test_right"},\n        "NotEqual": {"operator": "NotEqual", "leftKey": "test_left", "rightKey": "test_right"}}\n\n    def ifExists(self, existProp: Expr):\n        return replace(self, leftProp=existProp, condition="Exists")\n\n    def ifEqual(self, leftProp: Expr, rightProp: Expr):\n        return replace(self, leftProp=leftProp, rightProp=rightProp, condition="Equal")\n\n    def ifNotEqual(self, leftProp: Expr, rightProp: Expr):\n        return replace(self, leftProp=leftProp, rightProp=rightProp, condition="NotEqual")\n\n    def then(self, elementsWhenConditionTrue: Element):\n        return replace(self, consequent=[elementsWhenConditionTrue])\n\n    def otherwise(self, elementsWhenConditionFalse: Element):\n        return replace(self, alternate=[elementsWhenConditionFalse])\n\n    def jsonProperties(self) -> dict:\n        properties = super(Condition, self).jsonProperties()\n        properties["type"] = "Ternary"\n        conditionSpecificName = self.conditionSpecifics[self.condition]\n        properties["operator"] = conditionSpecificName["operator"]\n        if self.leftProp is not None:\n            properties[conditionSpecificName["leftKey"]] = self.leftProp.propertyPathExpr(PropertyContext("", ""))\n        if self.rightProp is not None:\n            properties[conditionSpecificName["rightKey"]] = self.rightProp.propertyPathExpr(PropertyContext("", ""))\n\n        consequentArray = []\n        for element in self.consequent:\n            consequentArray.append(element.json())\n        properties["consequent"] = consequentArray\n\n        alternateElemsArray = []\n        for element in self.alternate:\n            alternateElemsArray.append(element.json())\n        properties["alternate"] = alternateElemsArray\n\n        return properties\n\n\n\'\'\'---------------------------- Dataset -----------------------------------\'\'\'\n\n\n@dataclass(frozen=True)\nclass DatasetTemplate:\n    type: str\n    format: str\n    tabs: list\n\n    def json(self) -> dict:\n        properties = dict()\n        properties["type"] = self.type\n        properties["format"] = self.format\n        properties["tabs"] = list(map(lambda x: x.json(), self.tabs))\n        return properties\n\n\n@dataclass(frozen=True)\nclass Dataset(Container[Element]):\n    type: Optional[str]\n    format: Optional[str]\n    basicTemplate: Element\n    templates: List[DatasetTemplate] = field(default_factory=list)\n\n    def kind(self) -> str:\n        return "Dataset"\n\n    def children(self) -> list:\n        return []\n\n    def addTemplate(self, datasetTemplate: DatasetTemplate):\n        self.templates.append(datasetTemplate)\n        return replace(self, templates=self.templates)\n\n    def json(self) -> dict:\n        return super(Dataset, self).json()\n\n    def jsonProperties(self) -> dict:\n        properties = super(Dataset, self).jsonProperties()\n        if self.type is not None:\n            properties["type"] = self.type\n        if self.format is not None:\n            properties["format"] = self.format\n        properties["basicTemplate"] = self.basicTemplate.json()\n        properties["templates"] = list(map(lambda x: x.json(), self.templates))\n        return properties\n\n\n@dataclass(frozen=True)\nclass NewDataset(Container[Element]):\n    type: Optional[str]\n    format: Optional[str]\n    basicTemplate: Element\n    templates: List[DatasetTemplate] = field(default_factory=list)\n    cancelNewDataset: Optional = None\n    createNewDataset: Optional = None\n\n    def kind(self) -> str:\n        return "NewDataset"\n\n    def children(self) -> list:\n        return []\n\n    def addTemplate(self, datasetTemplate: DatasetTemplate):\n        self.templates.append(datasetTemplate)\n        return replace(self, templates=self.templates)\n\n    def cancelNewDataset(self, action):\n        return replace(self, cancelNewDataset=action)\n\n    def createNewDataset(self, action):\n        return replace(self, createNewDataset=action)\n\n    def json(self):\n        return super(NewDataset, self).json()\n\n    def jsonProperties(self) -> dict:\n        properties = super(NewDataset, self).jsonProperties()\n        if self.type is not None:\n            properties["type"] = self.type\n        if self.format is not None:\n            properties["format"] = self.format\n        properties["basicTemplate"] = self.basicTemplate.json()\n        properties["templates"] = list(map(lambda x: x.json(), self.templates))\n        actions = []\n        if self.createNewDataset is not None:\n            actions.append("createNewDataset")\n        if self.cancelNewDataset is not None:\n            actions.append("cancelNewDataset")\n        properties["actions"] = actions\n        return properties\n\n\n@dataclass\nclass HorizontalDivider(Container[Element]):\n    _children: list = None\n\n    def kind(self) -> str:\n        return "Atoms.Divider"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def jsonProperties(self) -> dict:\n        properties = super(HorizontalDivider, self).jsonProperties()\n        properties["type"] = "horizontal"\n        return properties\n\n\n@dataclass\nclass VerticalDivider(Container[Element]):\n    _children: list = None\n\n    def kind(self) -> str:\n        return "Atoms.Divider"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def jsonProperties(self) -> dict:\n        properties = super(VerticalDivider, self).jsonProperties()\n        properties["type"] = "vertical"\n        return properties\n\n\n@dataclass\nclass TitleElement(Container[NativeText]):\n    title: str\n    level: Optional[int] = None\n\n    def kind(self) -> str:\n        return "Atoms.Title"\n\n    def children(self) -> list:\n        return [NativeText(self.title)]\n\n    def setLevel(self, level: int):\n        return replace(self, level=level)\n\n    def jsonProperties(self) -> dict:\n        properties = super(TitleElement, self).jsonProperties()\n        if self.level is not None:\n            properties["level"] = self.level\n        return properties\n\n\n@dataclass\nclass SchemaColumnsDropdown(Atom):\n    titleVar: str\n    schema: Optional[str] = None\n    propertyVar: Optional[str] = None\n    options: List[SelectBoxOption] = field(default_factory=list)\n    optionProperty: Optional[str] = None\n    disabled: Optional[bool] = None\n    placeholder: Optional[str] = None\n    mode: Optional[str] = None\n    notFoundContent: Optional[str] = None\n    errorBindings: List[str] = field(default_factory=list)\n    showSearch: Optional[bool] = None\n    allowClear: Optional[bool] = None\n    appearance: Optional[str] = None # minimal\n    value: Optional[str] = None # s{component.properties.value}\n\n    def kind(self) -> str:\n        return "SchemaSelectBox"\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindSchema(self, schemaPath: str):\n        return replace(self, schema=schemaPath)\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withMultipleSelection(self):\n        return replace(self, mode="multiple")\n\n    def withDisabled(self):\n        return replace(self, disabled=True)\n\n    def withNoContentMessage(self, msg: str):\n        return replace(self, notFoundContent=msg)\n\n    def allowClearSelection(self):\n        return replace(self, allowClear=True)\n\n    def withSearchEnabled(self):\n        return replace(self, showSearch=True)\n\n    def showErrorsFor(self, *bindings):\n        return replace(self, errorBindings=bindings)\n\n    def jsonProperties(self):\n        properties = super(SchemaColumnsDropdown, self).jsonProperties()\n        if self.schema is not None:\n            properties["schema"] = self.propertyPath(self.schema)\n        if self.disabled is not None:\n            properties["disabled"] = self.disabled\n        if self.placeholder is not None:\n            properties["placeholder"] = self.placeholder\n        if self.mode is not None:\n            properties["mode"] = self.mode\n        if self.notFoundContent is not None:\n            properties["notFoundContent"] = self.notFoundContent\n        if self.showSearch is not None:\n            properties["showSearch"] = self.showSearch\n        if self.allowClear is not None:\n            properties["allowClear"] = self.allowClear\n        if self.appearance is not None:\n            properties["appearance"] = self.appearance\n        if self.value is not None:\n            properties["value"] = self.propertyPath(self.value)\n        if self.errorBindings is not None and len(self.errorBindings) > 0:\n            properties["errorBindings"] = list(\n                map(lambda bind: self.propertyPath(bind).replace("${", "").replace("}", ""), self.errorBindings))\n        return properties\n\n\ndef TargetLocation(pathProperty: str) -> StackLayout:\n    return StackLayout().addElement(\n        StackLayout(direction="vertical", gap="1rem", height="100bh")\n        .addElement(TextBox("Location")\n                    .bindPlaceholder("Enter location here or navigate through the File Browser")\n                    .bindProperty(pathProperty))\n        .addElement(FileBrowser().hideExecutionErrors().bindProperty(pathProperty)))\n\n\n@dataclass\nclass ScrollBox(Container[Element]):\n    property: Optional[str] = None\n    height: Optional[str] = "100%"\n    width: Optional[str] = None\n    _children: list = None\n    propertyVar: Optional[str] = None\n\n    def kind(self) -> str:\n        return "Atoms.ScrollBox"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def addElement(self, element: Element):\n        if self._children is None:\n            return replace(self, _children=[element])\n        else:\n            self._children.insert(0, element)\n            return replace(self, _children=self._children)\n\n    def jsonProperties(self) -> dict:\n        properties = super(ScrollBox, self).jsonProperties()\n        if self.height is not None:\n            properties["height"] = self.height\n        if self.width is not None:\n            properties["width"] = self.width\n        return properties\n\n\n@dataclass\nclass CatalogTableDB(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    tableProperty: Optional[str] = None\n    isCatalogEnabled: Optional[str] = None\n    catalog: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def kind(self) -> str:\n        return "Database"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def propertyKey(self) -> str:\n        return "database"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def bindTableProperty(self, property: str):\n        return replace(self, tableProperty=property)\n\n    def bindIsCatalogEnabledProperty(self, property: str):\n        return replace(self, isCatalogEnabled=property)\n\n    def bindCatalogProperty(self, property: str):\n        return replace(self, catalog=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(CatalogTableDB, self).jsonProperties()\n        if self.tableProperty is not None:\n            properties["table"] = self.propertyPath(self.tableProperty)\n        if self.isCatalogEnabled is not None:\n            properties["isCatalogEnabled"] = self.propertyPath(self.isCatalogEnabled)\n        if self.catalog is not None:\n            properties["catalog"] = self.propertyPath(self.catalog)\n        return properties\n\n\n@dataclass\nclass StackItem(Container[Element]):\n    _children: list = None\n    grow: Optional[int] = 0\n    shrink: Optional[int] = 1\n    basis: Optional[str] = "auto"\n\n    def kind(self) -> str:\n        return "Layouts.StackItem"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def addElement(self, element: Element):\n        if self._children is None:\n            return replace(self, _children=[element])\n        else:\n            self._children.insert(0, element)\n            return replace(self, _children=self._children)\n\n    def jsonProperties(self) -> dict:\n        properties = super(StackItem, self).jsonProperties()\n        if self.grow is not None:\n            properties["grow"] = self.grow\n        if self.shrink is not None:\n            properties["shrink"] = self.shrink\n        if self.basis is not None:\n            properties["basis"] = self.basis\n        return properties\n\n\n@dataclass\nclass OptionField:\n    key: str\n    field: Element\n    hideDelete: bool = False\n\n@dataclass\nclass PickerTab:\n    label: str\n    value: str\n    isDefault: bool = False\n    propertyVar: Optional[str] = "component.properties"\n    fields: List[OptionField] = None\n\n    def addFields(self, fields: List[OptionField]):\n        if self.fields is None:\n            return replace(self, fields=fields)\n        else:\n            newFields = copy.deepcopy(self.fields)\n            newFields.extend(fields)\n            return replace(self, fields=newFields)\n\n    def addField(self, child: Atom, key: str, hideDelete: bool = False):\n        optionField = OptionField(key, child.bindProperty(f"{self.propertyVar}.{key}"), hideDelete)\n        if self.fields is None:\n            return replace(self, fields=[optionField])\n        else:\n            newFields = copy.deepcopy(self.fields)\n            newFields.append(optionField)\n            return replace(self, fields=newFields)\n\n    def json(self) -> dict:\n        ff = []\n        if self.fields is not None:\n            for field in self.fields:\n                entry = {"key": field.key, "field": field.field.json()}\n                if field.hideDelete:\n                    entry["hideDelete"] = True\n                ff.append(entry)\n\n        return {\n            "label": self.label,\n            "value": self.value,\n            "isDefault": self.isDefault,\n            "dataset": propertyPath(self.propertyVar),\n            "fields": ff\n        }\n\n\n@dataclass\nclass FieldPickerWithTabs(Container[Element]):\n    title: Optional[str] = None\n    height: Optional[str] = None\n    tabs: Optional[List[PickerTab]] = None\n    _children: list = None\n\n    def kind(self) -> str:\n        return "Atoms.FieldPickerWithTabs"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def addTab(self, pickerTab: PickerTab):\n        if self.tabs is None:\n            return replace(self, tabs=[pickerTab])\n        else:\n            self.tabs.append(pickerTab)\n            return replace(self, tabs=self.tabs)\n\n    def jsonProperties(self) -> dict:\n        properties = super(FieldPickerWithTabs, self).jsonProperties()\n        if self.title is not None:\n            properties["title"] = self.title\n        if self.height is not None:\n            properties["height"] = self.height\n        if self.tabs is not None:\n            fields = []\n            for tab in self.tabs:\n                fields.append(tab.json())\n            properties["tabs"] = fields\n        return properties\n\n\n@dataclass\nclass FieldPicker(Container[Element]):\n    _children: list = None\n    fields: List[OptionField] = None\n    height: Optional[str] = None\n    propertyVar: Optional[str] = "component.properties"\n    title: Optional[str] = None\n\n    def kind(self) -> str:\n        return "Atoms.FieldPicker"\n\n    def children(self) -> list:\n        if self._children is None:\n            return []\n        else:\n            return self._children\n\n    def addField(self, child: Atom, key: str, hideDelete: bool = False):\n        optionField = OptionField(key, child.bindProperty(f"{self.propertyVar}.{key}"), hideDelete)\n        if self.fields is None:\n            return replace(self, fields=[optionField])\n        else:\n            newFields = copy.deepcopy(self.fields)\n            newFields.insert(0, optionField)\n            return replace(self, fields=newFields)\n\n    def jsonProperties(self) -> dict:\n        properties = super(FieldPicker, self).jsonProperties()\n        properties["dataset"] = self.propertyPath(self.propertyVar)\n        fields = []\n        if self.fields is not None:\n            reversedFields = reversed(self.fields)\n            for field in reversedFields:\n                entry = {"key": field.key, "field": field.field.json()}\n                if (field.hideDelete):\n                    entry["hideDelete"] = True\n                fields.append(entry)\n        properties["fields"] = fields\n        if self.height is not None:\n            properties["height"] = self.height\n        if self.title is not None:\n            properties["title"] = self.title\n        return properties\n\n\n@dataclass\nclass SchemaTable(Atom):\n    titleVar: str\n    readOnly: bool = False\n    allowInferSchema: bool = True\n    propertyVar: Optional[str] = None\n\n    def kind(self) -> str:\n        return "SchemaTable"\n\n    def propertyKey(self) -> str:\n        return "schema"\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def isReadOnly(self, readOnly: bool = True):\n        return replace(self, readOnly=readOnly)\n\n    def withoutInferSchema(self):\n        return replace(self, allowInferSchema=False)\n\n    def jsonProperties(self):\n        properties = super(SchemaTable, self).jsonProperties()\n        properties["readOnly"] = self.readOnly\n        properties["allowInferSchema"] = self.allowInferSchema\n        return properties\n\n\n@dataclass\nclass Credentials(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Credentials"\n\n    def propertyKey(self) -> str:\n        return "scope"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        properties = super(Credentials, self).jsonProperties()\n        return properties\n\n\n@dataclass\nclass SecretBox(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    placeholder: str = ""\n    allowPlainText: Optional[bool] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def kind(self) -> str:\n        return "Atoms.Secret"\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def isPassword(self):\n        return replace(self, allowPlainText=False)\n\n    def bindPlaceholder(self, placeHolder: str):\n        return replace(self, placeholder=placeHolder)\n\n    def jsonProperties(self) -> dict:\n        props = super(SecretBox, self).jsonProperties()\n        props["title"] = self.title()\n        if self.allowPlainText is not None:\n            props["allowPlainText"] = self.allowPlainText\n        props["placeholder"] = self.placeholder\n        return props\n\n# Button to sign in using OAuth in Orchetrator connector creation flow\n@dataclass\nclass OAuthButton(Atom):\n    _title: str\n    host: Optional[str] = None\n    provider: Optional[str] = None\n    connectorKind: Optional[str] = None\n    _kind: str = "Atoms.OAuthButton"\n    propertyVar: Optional[str] = None\n\n    def title(self) -> str:\n        return self._title\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withHost(self, host: str):\n        return replace(self, host=host)\n\n    def withProvider(self, provider: str):\n        return replace(self, provider=provider)\n\n    def withConnectorKind(self, connectorKind: str):\n        return replace(self, connectorKind=connectorKind)\n\n    def kind(self):\n        return self._kind\n\n    def jsonProperties(self) -> dict:\n        props = super(OAuthButton, self).jsonProperties()\n        if self.host is not None:\n            props["host"] = self.host\n        if self.provider is not None:\n            props["provider"] = self.provider\n        if self.connectorKind is not None:\n            props["connectorKind"] = self.connectorKind\n        return props\n\n@dataclass\nclass TextBoxTemplate(Container[Element]):\n    titleVar: str\n    identifierVar: str\n    templateVar: StackLayout\n    _kind: str = "Layouts.Stack"\n    _children: List[Element] = field(default_factory=list)\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def identifier(self) -> Optional[str]:\n        return self.identifierVar\n\n    def template(self) -> StackLayout:\n        return self.templateVar\n\n    def kind(self) -> str:\n        return self._kind\n\n    def children(self) -> list:\n        return self._children\n\n    def jsonProperties(self) -> dict:\n        props = super(TextBoxTemplate, self).jsonProperties()\n        props["identifier"] = self.identifier()\n        props["template"] = self.template().json()\n        return props\n\n    @staticmethod\n    def create_job_size_template(titleVar: str, identifier: str):\n        sub_template: StackLayout = StackLayout().addTemplate(\n            StackLayout(align="space-between", direction="horizontal").addElement(\n                child=Text(_children=[NativeText("${job_sizes.label}")])))\n\n        return TextBoxTemplate(titleVar, identifier, templateVar=sub_template,\n                               _children=[NativeText("${record.label}")])\n\n    @staticmethod\n    def create_pipeline_template(titleVar: str, identifier: str):\n        sub_template: StackLayout = StackLayout().addTemplate(\n            StackLayout(align="space-between", direction="horizontal").addElement(\n                child=Text(_children=[NativeText("${pipelines.label}")])))\n\n        return TextBoxTemplate(titleVar, identifier, templateVar=sub_template,\n                               _children=[NativeText("${record.label}")])\n\n    @staticmethod\n    def create_airflow_connection_template(titleVar: str, identifier: str):\n        sub_template: StackLayout = StackLayout().addTemplate(\n            StackLayout(align="space-between", direction="horizontal").addElement(\n                child=Text(_children=[NativeText("${record.label}")])))\n\n        return TextBoxTemplate(titleVar, identifier, templateVar=sub_template,\n                               _children=[NativeText("${record.label}")])\n\n    @staticmethod\n    def create_airflow_dag_template(titleVar: str, identifier: str):\n        sub_template: StackLayout = StackLayout().addTemplate(\n            StackLayout(align="space-between", direction="horizontal").addElement(\n                child=Text(_children=[NativeText("${projects.git_branches_and_release_tags.label}")])))\n\n        return TextBoxTemplate(titleVar, identifier, templateVar=sub_template,\n                               _children=[NativeText("${record.label}")])\n\n    @staticmethod\n    def create_model_template():\n        return NativeText("${record.label}")\n\n\n    @staticmethod\n    def create_project_template(titleVar: str, identifier: str):\n        sub_template: StackLayout = StackLayout().addTemplate(\n            StackLayout(align="space-between", direction="horizontal").addElement(\n                child=Condition().ifEqual(PropExpr("projects.disabled"), BooleanExpr(True))\n                .then(Text(_children=[NativeText("${projects.label}")],\n                           tooltip="Prophecy Managed git projects cannot be scheduled"))\n                .otherwise(Text(_children=[NativeText("${projects.label}")]))\n            ))\n\n        return TextBoxTemplate(titleVar, identifier, templateVar=sub_template,\n                               _children=[NativeText("${record.label}")])\n\n    @staticmethod\n    def create_fabric_template(titleVar: str, identifier: str):\n        sub_template: StackLayout = StackLayout().addTemplate(\n            StackLayout(direction="horizontal").addElement(\n                StackLayout(direction="horizontal", width="100%", gap="8px")\n                .addElement(StackLayout().addElement(FabricIcon(provider="SQL", providerType="${fabrics.type}")))\n                .addElement(child=Text(_children=[NativeText("${fabrics.label}")]))))\n\n        return TextBoxTemplate(titleVar, identifier, templateVar=sub_template,\n                               _children=[NativeText("${record.label}")])\n\n@dataclass\nclass SelectBoxWithTemplate(Atom):\n    titleVar: str\n    propertyVar: Optional[str] = None\n    options: List[SelectBoxOption] = field(default_factory=list)\n    optionProperty: Optional[str] = None\n    disabled: Optional[bool] = None\n    allowConfig: Optional[bool] = None\n    style: Optional[dict] = None\n    placeholder: Optional[str] = None\n    mode: Optional[str] = None\n    notFoundContent: Optional[str] = None\n    showSearch: Optional[bool] = None\n    _identifier: Optional[str] = None\n    _template: Optional[TextBoxTemplate] = None\n    disableOption: Optional[bool] = None\n    optionFilterProp: Optional[str] = None\n    hasGroupName: Optional[bool] = None\n    _kind: str = "Atoms.SelectBox"\n    optionCTA: Optional[Element] = None\n\n    def title(self) -> str:\n        return self.titleVar\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def identifier(self) -> Optional[str]:\n        return self._identifier\n\n    def template(self) -> Optional[TextBoxTemplate]:\n        return self._template\n\n    def kind(self) -> str:\n        return self._kind\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def withNoContentMessage(self, msg: str):\n        return replace(self, notFoundContent=msg)\n\n    def bindOptionProperty(self, property: str):\n        return replace(self, optionProperty=property)\n\n    def withStyle(self, style: dict):\n        return replace(self, style=style)\n\n    def withAllowConfig(self):\n        return replace(self, allowConfig=True)\n\n    def withSearchEnabled(self):\n        return replace(self, showSearch=True)\n\n    def withIdentifier(self, identifier: str):\n        return replace(self, _identifier=identifier)\n\n    def withFilterProp(self, filterProp: str):\n        return replace(self, optionFilterProp=filterProp)\n\n    def withGroupName(self):\n        return replace(self, hasGroupName=True)\n\n    def addTemplate(self, template: TextBoxTemplate):\n        return replace(self, _template=template)\n\n    def withOptionCTA(self, cta: Element):\n        return replace(self, optionCTA=cta)\n\n    def jsonProperties(self) -> dict:\n        props = super(SelectBoxWithTemplate, self).jsonProperties()\n        props["identifier"] = self.identifier()\n        props["template"] = self.template().json()\n        if self.disableOption is not None:\n            props["disableOption"] = self.disableOption\n        if self.showSearch is not None:\n            props["showSearch"] = self.showSearch\n        if self.allowConfig is not None:\n            props["allowConfig"] = self.allowConfig\n        if self.notFoundContent is not None:\n            props["notFoundContent"] = self.notFoundContent\n        if self.mode is not None:\n            props["mode"] = self.mode\n        if self.placeholder is not None:\n            props["placeholder"] = self.placeholder\n        if self.disabled is not None:\n            props["disabled"] = self.disabled\n        if self.style is not None:\n            props["style"] = self.style\n        if self.optionFilterProp is not None:\n            props["optionFilterProp"] = self.optionFilterProp\n        if self.hasGroupName is not None:\n            props["hasGroupName"] = self.hasGroupName\n        if self.optionCTA is not None:\n            props["optionCTA"] = self.optionCTA.json()\n\n        # Label -> value generation for options in absence of option property\n        if self.optionProperty is not None:\n            props["options"] = self.optionProperty\n        elif self.options is not None:\n            options_json_array = []\n            for opt in self.options:\n                options_json_array.append({"label": opt.label, "value": opt.value})\n            props["options"] = options_json_array\n        return props\n\n\n@dataclass\nclass ImagePlaceholder(Atom):\n    gem: Gem\n    _title: str\n    icon: Optional[str] = None\n    propertyVar: Optional[str] = None\n    _kind: str = "Atoms.ImagePlaceholder"\n\n    def title(self) -> str:\n        return self._title\n\n    def kind(self) -> str:\n        return self._kind\n\n    def property(self) -> Optional[str]:\n        return self.propertyVar\n\n    def bindProperty(self, property: str):\n        return replace(self, propertyVar=property)\n\n    def jsonProperties(self) -> dict:\n        props = super(ImagePlaceholder, self).jsonProperties()\n        props["gem"] = self.gem.name\n        if self.icon is not None:\n            props["icon"] = self.icon\n        return props\n\n\n@dataclass\nclass PipelineConfigurationTable(Atom):\n    _title: str = "Pipeline Configurations"\n    _schemaProperty: str = "${component.properties.configurations.schema}"\n    _selectedInstanceProperty: str = "${component.properties.configurations.selectedInstance}"\n    _instancesProperty: str = "${component.properties.configurations.instances}"\n    _overridesProperty: str = "${component.properties.configurations.overrides}"\n    _clusterSizeProperty: str = "${component.properties.clusterSize}"\n    _property: Optional[str] = None\n    _kind: str = "Atoms.PipelineConfiguration"\n\n    def title(self) -> str:\n        return self._title\n\n    def kind(self) -> str:\n        return self._kind\n\n    def property(self) -> Optional[str]:\n        return self._property\n\n    def schemaProperty(self) -> Optional[str]:\n        return self._schemaProperty\n\n    def selectedInstanceProperty(self) -> Optional[str]:\n        return self._selectedInstanceProperty\n\n    def instancesProperty(self) -> Optional[str]:\n        return self._instancesProperty\n\n    def overridesProperty(self) -> Optional[str]:\n        return self._overridesProperty\n\n    def clusterSizeProperty(self) -> Optional[str]:\n        return self._clusterSizeProperty\n\n    def bindProperty(self, property: str):\n        return replace(self, _property=property)\n\n    def jsonProperties(self) -> dict:\n        props = super(PipelineConfigurationTable, self).jsonProperties()\n        props["schema"] = self.schemaProperty()\n        props["selectedInstance"] = self.selectedInstanceProperty()\n        props["instances"] = self.instancesProperty()\n        props["overrides"] = self.overridesProperty()\n        props["clusterSize"] = self.clusterSizeProperty()\n        return props\n\n\n# -------------------------------- MACRO TABLE --------------------------------\n@dataclass\nclass MacroInstance(Atom):\n    _title: str\n    _property: Optional[str] = None\n    ports: Optional[str] = None\n    name: Optional[str] = None\n    projectName: Optional[str] = None\n\n    def title(self) -> str:\n        return self._title\n\n    def property(self) -> Optional[str]:\n        return self._property\n\n    def kind(self) -> str:\n        return "MacroInstance"\n\n    def bindProperty(self, property: str):\n        return replace(self, _property=property)\n\n    def withSchemaSuggestions(self):\n        return replace(self, ports="component.ports.inputs")\n\n    def jsonProperties(self) -> dict:\n        props = super().jsonProperties()\n        if self.ports is not None:\n            props[\'ports\'] = self.propertyPath(self.ports)\n        if self.name is not None:\n            props[\'macro\'] = self.propertyPath(self.name)\n        if self.projectName is not None:\n            props[\'projectName\'] = self.propertyPath(self.projectName)\n        return props\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(f,{...e})}):f(e)}},41604:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/AlertBox-a8ad3d0391b92fd5c8abf73a80b610f3.png"},45553:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/Switch-987f2b0803ea4e22d275742644c87db5.png"},47479:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/RadioGroup-abe056270e0adfd373f32a723522443c.png"},54029:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/TextBox-43de3b6e7ca9eb5f4eeef7c40a23aec6.png"},64438:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/Editor-dd7c3b6675bbdd9a790006ddd92aeb48.png"},85932:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/SchemaColumnsDropdown-6ac8a5ff12ef461e092a6d5986618e84.png"},90298:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/Markdown-699b432aca1779c909d06721115d1d78.png"},92545:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/Ports-b34be2b89ea69468862bd647833726ef.png"},95218:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/Checkbox-54e4293ac8ac4798b2882433d132141f.png"},96676:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/ExpressionBox-82e403b1dfaca4221c4a3714fad3936a.png"}}]);