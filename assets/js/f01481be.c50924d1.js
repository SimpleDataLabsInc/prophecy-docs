"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[1280],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>g});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=d(a),c=r,g=p["".concat(s,".").concat(c)]||p[c]||u[c]||l;return a?n.createElement(g,i(i({ref:t},m),{},{components:a})):n.createElement(g,i({ref:t},m))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},85162:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(67294),r=a(86010);const l={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,i),hidden:a},t)}},74866:(e,t,a)=>{a.d(t,{Z:()=>y});var n=a(87462),r=a(67294),l=a(86010),i=a(12466),o=a(16550),s=a(91980),d=a(67392),m=a(50012);function p(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function u(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function c(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:a}=e;const n=(0,o.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function k(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=u(e),[i,o]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[s,d]=g({queryString:a,groupId:n}),[p,k]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,m.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),h=(()=>{const e=s??p;return c({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{h&&o(h)}),[h]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!c({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),k(e)}),[d,k,l]),tabValues:l}}var h=a(72389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:a,selectedValue:o,selectValue:s,tabValues:d}=e;const m=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),u=e=>{const t=e.currentTarget,a=m.indexOf(t),n=d[a].value;n!==o&&(p(t),s(n))},c=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const a=m.indexOf(e.currentTarget)+1;t=m[a]??m[0];break}case"ArrowLeft":{const a=m.indexOf(e.currentTarget)-1;t=m[a]??m[m.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":a},t)},d.map((e=>{let{value:t,label:a,attributes:i}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>m.push(e),onKeyDown:c,onClick:u},i,{className:(0,l.Z)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":o===t})}),a??t)})))}function v(e){let{lazy:t,children:a,selectedValue:n}=e;if(a=Array.isArray(a)?a:[a],t){const e=a.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function N(e){const t=k(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",b.tabList)},r.createElement(f,(0,n.Z)({},e,t)),r.createElement(v,(0,n.Z)({},e,t)))}function y(e){const t=(0,h.Z)();return r.createElement(N,(0,n.Z)({key:String(t)},e))}},95415:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>d,toc:()=>p});var n=a(87462),r=(a(67294),a(3905)),l=a(74866),i=a(85162);const o={title:"Delta",id:"delta",description:"Delta",sidebar_position:5,tags:["gems","file","delta"]},s=void 0,d={unversionedId:"low-code-spark/gems/source-target/file/delta",id:"low-code-spark/gems/source-target/file/delta",title:"Delta",description:"Delta",source:"@site/docs/low-code-spark/gems/source-target/file/delta.md",sourceDirName:"low-code-spark/gems/source-target/file",slug:"/low-code-spark/gems/source-target/file/delta",permalink:"/low-code-spark/gems/source-target/file/delta",draft:!1,tags:[{label:"gems",permalink:"/tags/gems"},{label:"file",permalink:"/tags/file"},{label:"delta",permalink:"/tags/delta"}],version:"current",sidebarPosition:5,frontMatter:{title:"Delta",id:"delta",description:"Delta",sidebar_position:5,tags:["gems","file","delta"]},sidebar:"defaultSidebar",previous:{title:"Text",permalink:"/low-code-spark/gems/source-target/file/text"},next:{title:"JSON",permalink:"/low-code-spark/gems/source-target/file/json"}},m={},p=[{value:"Source",id:"source",level:2},{value:"Source Parameters",id:"source-parameters",level:3},{value:"Example",id:"source-example",level:3},{value:"Generated Code",id:"source-code",level:3},{value:"Without time travel",id:"without-time-travel",level:4},{value:"Timestamp-based time travel",id:"timestamp-based-time-travel",level:4},{value:"Version-based time travel",id:"version-based-time-travel",level:4},{value:"Target",id:"target",level:2},{value:"Target Parameters",id:"target-parameters",level:3},{value:"Supported Write Modes",id:"supported-write-modes",level:4},{value:"Target Example",id:"target-example",level:3},{value:"Generated Code",id:"target-code",level:3},{value:"Delta MERGE",id:"delta-merge",level:2},{value:"SCD1",id:"scd1",level:3},{value:"Parameters",id:"upsert-parameters",level:4},{value:"Example",id:"upsert-example",level:4},{value:"Generated Code",id:"upsert-code",level:4},{value:"SCD2",id:"scd2",level:3},{value:"Parameters",id:"scd2-parameters",level:4},{value:"Example",id:"scd2-example",level:4},{value:"Generated Code",id:"scd2-code",level:4},{value:"SCD3",id:"scd3",level:3}],u={toc:p},c="wrapper";function g(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,n.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reads and writes Delta tables, including Delta Merge operations and Time travel."),(0,r.kt)("h2",{id:"source"},"Source"),(0,r.kt)("h3",{id:"source-parameters"},"Source Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Location"),(0,r.kt)("td",{parentName:"tr",align:null},"File path for the Delta table"),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Read Timestamp"),(0,r.kt)("td",{parentName:"tr",align:null},"Time travel to a specific timestamp"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Read Version"),(0,r.kt)("td",{parentName:"tr",align:null},"Time travel to a specific version of table"),(0,r.kt)("td",{parentName:"tr",align:null},"False")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"For time travel on Delta tables:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"Only ",(0,r.kt)("inlineCode",{parentName:"li"},"Read Timestamp")," ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"OR"))," ",(0,r.kt)("inlineCode",{parentName:"li"},"Read Version")," can be selected, not both."),(0,r.kt)("li",{parentName:"ol"},"Timestamp should be between the first commit timestamp and the latest commit timestamp in the table."),(0,r.kt)("li",{parentName:"ol"},"Version needs to be an integer. Its value has to be between min and max version of table.")),(0,r.kt)("p",{parentName:"admonition"},"By default most recent version of each row is fetched if no time travel option is used.")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"To read more about Delta time travel and its use cases ",(0,r.kt)("a",{parentName:"p",href:"https://databricks.com/blog/2019/02/04/introducing-delta-time-travel-for-large-scale-data-lakes.html"},"click here"),".")),(0,r.kt)("h3",{id:"source-example"},"Example"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Delta source example",src:a(53860).Z,width:"1140",height:"608"})),(0,r.kt)("h3",{id:"source-code"},"Generated Code"),(0,r.kt)("h4",{id:"without-time-travel"},"Without time travel"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'def ReadDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,r.kt)(i.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object ReadDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n')))),(0,r.kt)("h4",{id:"timestamp-based-time-travel"},"Timestamp-based time travel"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'def ReadDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").option("timestampAsOf", "2022-05-05")\\\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,r.kt)(i.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object ReadDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").option("timestampAsOf", "2022-05-05")\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n')))),(0,r.kt)("h4",{id:"version-based-time-travel"},"Version-based time travel"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'def readDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").option("versionAsOf", "0")\\\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,r.kt)(i.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object readDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").option("versionAsOf", "0")\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n')))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"target"},"Target"),(0,r.kt)("h3",{id:"target-parameters"},"Target Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Location"),(0,r.kt)("td",{parentName:"tr",align:null},"File path to write the Delta table to"),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write mode"),(0,r.kt)("td",{parentName:"tr",align:null},"Write mode for DataFrame"),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Optimise write"),(0,r.kt)("td",{parentName:"tr",align:null},"If true, it optimizes Spark partition sizes based on the actual data"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Overwrite table schema"),(0,r.kt)("td",{parentName:"tr",align:null},"If true, overwrites the schema of the Delta table with the schema of the incoming DataFrame"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Merge schema"),(0,r.kt)("td",{parentName:"tr",align:null},"If true, then any columns that are present in the DataFrame but not in the target table are automatically added on to the end of the schema as part of a write transaction"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Partition Columns"),(0,r.kt)("td",{parentName:"tr",align:null},"List of columns to partition the Delta table by"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Overwrite partition predicate"),(0,r.kt)("td",{parentName:"tr",align:null},"If specified, then it selectively overwrites only the data that satisfies the given where clause expression."),(0,r.kt)("td",{parentName:"tr",align:null},"False")))),(0,r.kt)("h4",{id:"supported-write-modes"},"Supported Write Modes"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Write Mode"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"overwrite"),(0,r.kt)("td",{parentName:"tr",align:null},"If data already exists, overwrite with the contents of the DataFrame")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"append"),(0,r.kt)("td",{parentName:"tr",align:null},"If data already exists, append the contents of the DataFrame")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignore"),(0,r.kt)("td",{parentName:"tr",align:null},"If data already exists, do nothing with the contents of the DataFrame. This is similar to a ",(0,r.kt)("inlineCode",{parentName:"td"},"CREATE TABLE IF NOT EXISTS")," in SQL.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"error"),(0,r.kt)("td",{parentName:"tr",align:null},"If data already exists, throw an exception.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"merge"),(0,r.kt)("td",{parentName:"tr",align:null},"Insert, delete and update data using the Delta ",(0,r.kt)("inlineCode",{parentName:"td"},"merge")," command.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCD2 merge"),(0,r.kt)("td",{parentName:"tr",align:null},"It is a Delta merge operation that stores and manages both current and historical data over time.")))),(0,r.kt)("p",null,"Among these write modes overwrite, append, ignore and error works the same way as in case of parquet file writes.\nMerge will be explained with several examples in the following sections."),(0,r.kt)("h3",{id:"target-example"},"Target Example"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Delta Target Example",src:a(71296).Z,width:"1140",height:"608"})),(0,r.kt)("h3",{id:"target-code"},"Generated Code"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'def writeDelta(spark: SparkSession, in0: DataFrame):\n    return in0.write\\\n            .format("delta")\\\n            .option("optimizeWrite", True)\\\n            .option("mergeSchema", True)\\\n            .option("replaceWhere", "order_dt > \'2022-01-01\'")\\\n            .option("overwriteSchema", True)\\\n            .mode("overwrite")\\\n            .partitionBy("order_dt")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,r.kt)(i.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object writeDelta {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    in0.write\n        .format("delta")\n        .option("optimizeWrite", True)\n        .option("mergeSchema", True)\n        .option("replaceWhere", "order_dt > \'2022-01-01\'")\n        .option("overwriteSchema", True)\n        .mode("overwrite")\n        .partitionBy("order_dt")\n        .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n\n')))),(0,r.kt)("h2",{id:"delta-merge"},"Delta MERGE"),(0,r.kt)("p",null,"You can upsert data from a source DataFrame into a target Delta table by using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.delta.io/latest/delta-update.html#upsert-into-a-table-using-merge"},"MERGE")," operation. Delta MERGE supports ",(0,r.kt)("inlineCode",{parentName:"p"},"Insert"),"s, ",(0,r.kt)("inlineCode",{parentName:"p"},"Update"),"s, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Delete"),"s in a variety of use cases, and Delta is particularly suited to examine data with individual records that slowly change over time. Here we consider the most common types of slowly changing dimension (SCD) cases: SCD1, SCD2, and SCD3. Records are modified in one of the following ways: history is not retained (SCD1), history is retained at the row level (SCD2), or history is retained at the column level (SCD3)."),(0,r.kt)("h3",{id:"scd1"},"SCD1"),(0,r.kt)("p",null,"Let's take the simplest case to illustrate a MERGE condition."),(0,r.kt)("h4",{id:"upsert-parameters"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Source alias"),(0,r.kt)("td",{parentName:"tr",align:null},"Alias to use for the source DataFrame"),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Target alias"),(0,r.kt)("td",{parentName:"tr",align:null},"Alias to use for existing target Delta table"),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Merge Condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Condition to merge data from source DataFrame to target table, which would be used to perform update, delete, or insert actions as specified."),(0,r.kt)("td",{parentName:"tr",align:null},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Matched Update Action"),(0,r.kt)("td",{parentName:"tr",align:null},"Update the row from ",(0,r.kt)("inlineCode",{parentName:"td"},"Source")," that already exists in ",(0,r.kt)("inlineCode",{parentName:"td"},"Target")," (based on ",(0,r.kt)("inlineCode",{parentName:"td"},"Merge Condition"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Matched Update Condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional additional condition for updating row. If specified then it must evaluate to true for the row to be updated."),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Matched Update Expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional expressions for setting the values of columns that need to be updated."),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Matched Delete Action"),(0,r.kt)("td",{parentName:"tr",align:null},"Delete rows if ",(0,r.kt)("inlineCode",{parentName:"td"},"Merge Condition")," (and the optional additional condition) evaluates to ",(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Matched Delete Condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional additional condition for deleting row. If a condition is specified then it must evaluate to true for the row to be deleted."),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Not Matched Action"),(0,r.kt)("td",{parentName:"tr",align:null},"The action to perform if the row from ",(0,r.kt)("inlineCode",{parentName:"td"},"Source")," is not present in ",(0,r.kt)("inlineCode",{parentName:"td"},"Target")," (based on ",(0,r.kt)("inlineCode",{parentName:"td"},"Merge Condition"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Not Matched Condition"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional condition for inserting row. If a condition is specified then it must evaluate to true for the row to be updated."),(0,r.kt)("td",{parentName:"tr",align:null},"False")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"When Not Matched Expressions"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional expressions for setting the values of columns that need to be updated."),(0,r.kt)("td",{parentName:"tr",align:null},"False")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"At least one action out of update, delete or insert needs to be set."),(0,r.kt)("li",{parentName:"ol"},"Delete removes the data from the latest version of the Delta table but does not remove it from the physical storage until the old versions are explicitly vacuumed. See ",(0,r.kt)("a",{parentName:"li",href:"https://docs.delta.io/latest/delta-utility.html#-delta-vacuum"},"vacuum")," for details."),(0,r.kt)("li",{parentName:"ol"},"A merge operation can fail if multiple rows of the source DataFrame match and the merge attempts to update the same rows of the target Delta table. Deduplicate gem can be placed before target if duplicate rows at source are expected."))),(0,r.kt)("p",null,"When possible, provide predicates on the partition columns for a partitioned Delta table as such predicates can significantly speed up the operations."),(0,r.kt)("h4",{id:"upsert-example"},"Example"),(0,r.kt)("p",null,"Let's assume our initial customers table is as below:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Initial customer table",src:a(30562).Z,width:"2884",height:"636"})),(0,r.kt)("p",null,"And we have the below updates coming into customers table"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Customer table updates",src:a(13840).Z,width:"2886",height:"530"})),(0,r.kt)("p",null,"Our output and configurations for SCD1 merge will look like below:"),(0,r.kt)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"}},(0,r.kt)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"}},(0,r.kt)("iframe",{src:"https://user-images.githubusercontent.com/103921419/173252757-0a1165f0-68e2-41ca-b6eb-58da51cb76d1.mp4",title:"SCD3",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"}))),(0,r.kt)("h4",{id:"upsert-code"},"Generated Code"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'def writeDeltaMerge(spark: SparkSession, in0: DataFrame):\n    from delta.tables import DeltaTable, DeltaMergeBuilder\n\n    if DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1"):\n        DeltaTable\\\n            .forPath(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\\\n            .alias("target")\\\n            .merge(in0.alias("source"), (col("source.customer_id") == col("target.customer_id")))\\\n            .whenMatchedUpdateAll()\\\n            .whenNotMatchedInsertAll()\\\n            .execute()\n    else:\n        in0.write\\\n            .format("delta")\\\n            .mode("overwrite")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\n\n'))),(0,r.kt)(i.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object writeDeltaMerge {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    import _root_.io.delta.tables._\n    if (DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")) {\n        DeltaTable\n            .forPath(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\n            .as("target")\n            .merge(in0.as("source"), (col("source.customer_id") === col("target.customer_id")))\n            .whenMatched()\n            .updateAll()\n            .whenNotMatched()\n            .insertAll()\n            .execute()\n    }\n    else {\n        in0.write\n            .format("delta")\n            .mode("overwrite")\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\n    }\n  }\n\n}\n\n')))),(0,r.kt)("h3",{id:"scd2"},"SCD2"),(0,r.kt)("p",null,"Let's use the Delta log to capture the historical ",(0,r.kt)("inlineCode",{parentName:"p"},"customer_zip_code")," at the row-level."),(0,r.kt)("h4",{id:"scd2-parameters"},"Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Required"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Key columns"),(0,r.kt)("td",{parentName:"tr",align:"left"},"List of key columns which would remain constant"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Historic columns"),(0,r.kt)("td",{parentName:"tr",align:"left"},"List of columns which would change over time for which history needs to be maintained"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"From time column"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Time from which a particular row became valid"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"To time column"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Time till which a particular row was valid"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Min/old-value flag"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Column placeholder to store the flag as true for the first entry of a particular key"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Max/latest flag"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Column placeholder to store the flag as true for the last entry of a particular key"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Flag values"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Option to choose the min/max flag to be true/false or 0/1"),(0,r.kt)("td",{parentName:"tr",align:"left"},"True")))),(0,r.kt)("h4",{id:"scd2-example"},"Example"),(0,r.kt)("p",null,"Using the same customer tables as in our merge example above, output and configurations for SCD2 merge will look like below:"),(0,r.kt)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"}},(0,r.kt)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"}},(0,r.kt)("iframe",{src:"https://user-images.githubusercontent.com/103921419/173252742-00930084-b3b3-4b8a-b5bb-59f39b74792b.mp4",title:"SCD3",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"}))),(0,r.kt)("h4",{id:"scd2-code"},"Generated Code"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'def writeDeltaSCD2(spark: SparkSession, in0: DataFrame):\n    from delta.tables import DeltaTable, DeltaMergeBuilder\n\n    if DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"):\n        existingTable = DeltaTable.forPath(\n            spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n        )\n        updatesDF = in0.withColumn("minFlag", lit("true")).withColumn(\n            "maxFlag", lit("true")\n        )\n        existingDF = existingTable.toDF()\n        updateColumns = updatesDF.columns\n        stagedUpdatesDF = (\n            updatesDF.join(existingDF, ["customer_id"])\n            .where(\n                (\n                    (existingDF["maxFlag"] == lit("true"))\n                    & (\n                        (\n                            (\n                                existingDF["customer_zip_code"]\n                                != updatesDF["customer_zip_code"]\n                            )\n                            | (\n                                existingDF["customer_city"]\n                                != updatesDF["customer_city"]\n                            )\n                        )\n                        | (existingDF["customer_state"] != updatesDF["customer_state"])\n                    )\n                )\n            )\n            .select(*[updatesDF[val] for val in updateColumns])\n            .withColumn("minFlag", lit("false"))\n            .withColumn("mergeKey", lit(None))\n            .union(updatesDF.withColumn("mergeKey", concat("customer_id")))\n        )\n        existingTable.alias("existingTable").merge(\n            stagedUpdatesDF.alias("staged_updates"),\n            concat(existingDF["customer_id"]) == stagedUpdatesDF["mergeKey"],\n        ).whenMatchedUpdate(\n            condition=(\n                (existingDF["maxFlag"] == lit("true"))\n                & (\n                    (\n                        (\n                            existingDF["customer_zip_code"]\n                            != stagedUpdatesDF["customer_zip_code"]\n                        )\n                        | (\n                            existingDF["customer_city"]\n                            != stagedUpdatesDF["customer_city"]\n                        )\n                    )\n                    | (\n                        existingDF["customer_state"]\n                        != stagedUpdatesDF["customer_state"]\n                    )\n                )\n            ),\n            set={"maxFlag": "false", "end_date": "staged_updates.updated_dt"},\n        )\\\n        .whenNotMatchedInsertAll()\\\n        .execute()\n    else:\n        in0.write\\\n            .format("delta")\\\n            .mode("overwrite")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2")\n\n\n'))),(0,r.kt)(i.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object writeDeltaSCD2 {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    import _root_.io.delta.tables._\n    if (\n      DeltaTable.isDeltaTable(\n        spark,\n        "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n      )\n    ) {\n      val updatesDF = in\n        .withColumn("minFlag", lit("true"))\n        .withColumn("maxFlag", lit("true"))\n      val existingTable: DeltaTable = DeltaTable.forPath(\n        spark,\n        "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n      )\n      val existingDF: DataFrame = existingTable.toDF\n      val stagedUpdatesDF = updatesDF\n        .join(existingDF, List("customer_id"))\n        .where(\n          existingDF.col("maxFlag") === lit("true") && List(\n            existingDF.col("customer_zip_code") =!= updatesDF\n              .col("customer_zip_code"),\n            existingDF.col("customer_city") =!= updatesDF\n              .col("customer_city"),\n            existingDF.col("customer_state") =!= updatesDF\n              .col("customer_state")\n          ).reduce((c1, c2) => c1 || c2)\n        )\n        .select(updatesDF.columns.map(x => updatesDF.col(x)): _*)\n        .withColumn("minFlag", lit("false"))\n        .withColumn("mergeKey", lit(null))\n        .union(updatesDF.withColumn("mergeKey", concat(col("customer_id"))))\n      existingTable\n        .as("existingTable")\n        .merge(\n          stagedUpdatesDF.as("staged_updates"),\n          concat(existingDF.col("customer_id")) === stagedUpdatesDF(\n            "mergeKey"\n          )\n        )\n        .whenMatched(\n          existingDF.col("maxFlag") === lit("true") && List(\n            existingDF.col("customer_zip_code") =!= stagedUpdatesDF\n              .col("customer_zip_code"),\n            existingDF.col("customer_city") =!= stagedUpdatesDF\n              .col("customer_city"),\n            existingDF.col("customer_state") =!= stagedUpdatesDF\n              .col("customer_state")\n          ).reduce((c1, c2) => c1 || c2)\n        )\n        .updateExpr(\n          Map("maxFlag" \u2192 "false", "end_date" \u2192 "staged_updates.updated_dt")\n        )\n        .whenNotMatched()\n        .insertAll()\n        .execute()\n    } else {\n      in0.write\n        .format("delta")\n        .mode("overwrite")\n        .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n    }\n\n  }\n\n}\n\n\n')))),(0,r.kt)("h3",{id:"scd3"},"SCD3"),(0,r.kt)("p",null,"Using the same customer tables as in our merge example above, output and configurations for SCD3 merge will look like below. Let's track change for ",(0,r.kt)("inlineCode",{parentName:"p"},"customer_zip_code")," by adding a column to show the previous value."),(0,r.kt)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"}},(0,r.kt)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"}},(0,r.kt)("iframe",{src:"https://user-images.githubusercontent.com/103921419/173252728-8924f0fb-6e81-44b7-9c39-17ba1d8f4d4c.mp4",title:"SCD3",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"}))),(0,r.kt)("hr",null),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"To check out our blogpost on making data lakehouse easier using Delta with Prophecy ",(0,r.kt)("a",{parentName:"p",href:"https://www.prophecy.io/blogs/prophecy-with-delta"},"click here"),".")))}g.isMDXComponent=!0},30562:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/delta_customers_initial_eg1-bd4fa7277b1fe2accbe931d2d51ed46a.png"},13840:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/delta_customers_updates_eg1-2ebf4ee81ff2c6c649073211bec6d9ea.png"},53860:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/delta_source_eg-a9bacfae161d215a8ceeec0330f206b3.gif"},71296:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/delta_target_eg-c6f697a3f02a7267907d97f5556e1468.gif"}}]);