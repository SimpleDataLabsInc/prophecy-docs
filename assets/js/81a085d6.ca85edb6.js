"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[78726],{28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>l});var s=a(96540);const r={},n=s.createContext(r);function i(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(n.Provider,{value:t},e.children)}},30357:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"Spark/gems/source-target/file/delta","title":"Delta","description":"Parameters and properties to read from and write to Delta files","source":"@site/docs/Spark/gems/source-target/file/delta.md","sourceDirName":"Spark/gems/source-target/file","slug":"/Spark/gems/source-target/file/delta","permalink":"/Spark/gems/source-target/file/delta","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"gems","permalink":"/tags/gems"},{"inline":true,"label":"file","permalink":"/tags/file"},{"inline":true,"label":"delta","permalink":"/tags/delta"}],"version":"current","frontMatter":{"title":"Delta","id":"delta","description":"Parameters and properties to read from and write to Delta files","tags":["gems","file","delta"]},"sidebar":"mySidebar","previous":{"title":"Data Generator","permalink":"/Spark/gems/source-target/file/data-generator"},"next":{"title":"Fixed Format","permalink":"/Spark/gems/source-target/file/fixed-format"}}');var r=a(74848),n=a(28453),i=a(49235),l=a(65537),d=a(79329);const o={title:"Delta",id:"delta",description:"Parameters and properties to read from and write to Delta files",tags:["gems","file","delta"]},c=void 0,h={},p=[{value:"Parameters",id:"parameters",level:2},{value:"Source",id:"source",level:2},{value:"Source properties",id:"source-properties",level:3},{value:"Example",id:"source-example",level:3},{value:"Generated Code",id:"source-code",level:3},{value:"Without time travel",id:"without-time-travel",level:4},{value:"Timestamp-based time travel",id:"timestamp-based-time-travel",level:4},{value:"Version-based time travel",id:"version-based-time-travel",level:4},{value:"Target",id:"target",level:2},{value:"Target properties",id:"target-properties",level:3},{value:"Supported write modes",id:"supported-write-modes",level:3},{value:"Target Example",id:"target-example",level:3},{value:"Generated Code",id:"target-code",level:3},{value:"Delta MERGE",id:"delta-merge",level:2},{value:"SCD1",id:"scd1",level:3},{value:"Properties",id:"upsert-properties",level:4},{value:"Example",id:"upsert-example",level:4},{value:"Generated Code",id:"upsert-code",level:4},{value:"SCD2",id:"scd2",level:3},{value:"Parameters",id:"scd2-properties",level:4},{value:"Example",id:"scd2-example",level:4},{value:"Generated Code",id:"scd2-code",level:4},{value:"SCD3",id:"scd3",level:3}];function u(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.A,{python_package_name:"ProphecySparkBasicsPython",python_package_version:"0.0.1+",scala_package_name:"ProphecySparkBasicsScala",scala_package_version:"0.0.1+",scala_lib:"",python_lib:"",uc_single:"14.3+",uc_shared:"14.3+",livy:"Not Supported"}),"\n",(0,r.jsx)(t.p,{children:"A Delta (Delta Lake) file type:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Is an optimized storage layer that allows you to store data and tables in the Databricks lakehouse."}),"\n",(0,r.jsx)(t.li,{children:"Extends Parquet data files with a file-based transaction log for ACID transactions and scalable metadata handling."}),"\n",(0,r.jsx)(t.li,{children:"Has a tight integration with structured streaming, which allows you to use a single copy of data for both batch and streaming operations and provides incremental processing at scale."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Parameter"}),(0,r.jsx)(t.th,{children:"Tab"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Location"}),(0,r.jsx)(t.td,{children:"Location"}),(0,r.jsx)(t.td,{children:"File path to read from or write to the Delta file."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Schema"}),(0,r.jsx)(t.td,{children:"Properties"}),(0,r.jsxs)(t.td,{children:["Schema to apply on the loaded data.",(0,r.jsx)("br",{}),"In the Source gem, you can define or edit the schema visually or in JSON code.",(0,r.jsx)("br",{}),"In the Target gem, you can view the schema visually or as JSON code."]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"source",children:"Source"}),"\n",(0,r.jsx)(t.p,{children:"The Source gem reads data from Delta files and allows you to optionally specify the following additional properties."}),"\n",(0,r.jsx)(t.h3,{id:"source-properties",children:"Source properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Default"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Description"}),(0,r.jsx)(t.td,{children:"Description of your dataset."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Read timestamp"}),(0,r.jsxs)(t.td,{children:["Time travel to a specific timestamp.",(0,r.jsx)("br",{}),"This value is between the first commit timestamp and the latest commit timestamp in the table."]}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Read version"}),(0,r.jsxs)(t.td,{children:["Time travel to a specific version of the table.",(0,r.jsx)("br",{}),"This value is an interger between the minimum and maximum version of the table. ",(0,r.jsx)("br",{}),"By default, the Source gem fetches the most recent version of each row if you don't use a time travel option."]}),(0,r.jsx)(t.td,{children:"None"})]})]})]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["You can only select ",(0,r.jsx)(t.code,{children:"Read Timestamp"})," or ",(0,r.jsx)(t.code,{children:"Read Version"}),", not both."]})}),"\n",(0,r.jsx)(t.h3,{id:"source-example",children:"Example"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Delta source example",src:a(83607).A+"",width:"1140",height:"608"})}),"\n",(0,r.jsx)(t.h3,{id:"source-code",children:"Generated Code"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["To see the generated source code of your project, ",(0,r.jsx)(t.a,{href:"/engineers/project-lifecycle/#review-the-code",children:"switch to the Code view"})," in the project header."]})}),"\n",(0,r.jsx)(t.h4,{id:"without-time-travel",children:"Without time travel"}),"\n","\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(d.A,{value:"py",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'def ReadDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n'})})}),(0,r.jsx)(d.A,{value:"scala",label:"Scala",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object ReadDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n'})})})]}),"\n",(0,r.jsx)(t.h4,{id:"timestamp-based-time-travel",children:"Timestamp-based time travel"}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(d.A,{value:"py",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'def ReadDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").option("timestampAsOf", "2022-05-05")\\\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n'})})}),(0,r.jsx)(d.A,{value:"scala",label:"Scala",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object ReadDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").option("timestampAsOf", "2022-05-05")\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n'})})})]}),"\n",(0,r.jsx)(t.h4,{id:"version-based-time-travel",children:"Version-based time travel"}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(d.A,{value:"py",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'def readDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").option("versionAsOf", "0")\\\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n'})})}),(0,r.jsx)(d.A,{value:"scala",label:"Scala",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object readDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").option("versionAsOf", "0")\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n'})})})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"target",children:"Target"}),"\n",(0,r.jsx)(t.p,{children:"The Target gem writes data to Delta files and allows you to optionally specify the following additional properties."}),"\n",(0,r.jsx)(t.h3,{id:"target-properties",children:"Target properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Default"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Description"}),(0,r.jsx)(t.td,{children:"Description of your dataset."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Write Mode"}),(0,r.jsxs)(t.td,{children:["How to handle existing data. For a list of the possible values, see ",(0,r.jsx)(t.a,{href:"#supported-write-modes",children:"Supported write modes"}),"."]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"error"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Overwrite table schema"}),(0,r.jsxs)(t.td,{children:["Whether to overwrite the schema of the Delta table with the schema of the incoming ",(0,r.jsx)(t.code,{children:"DataFrame"}),"."]}),(0,r.jsx)(t.td,{children:"false"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{children:["Merge ",(0,r.jsx)(t.code,{children:"DataFrame"})," schema into table schema"]}),(0,r.jsxs)(t.td,{children:["Whether to automatically add any columns present in the ",(0,r.jsx)(t.code,{children:"DataFrame"})," but not in the target table to the end of the schema as part of a write transaction."]}),(0,r.jsx)(t.td,{children:"false"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Partition Columns"}),(0,r.jsx)(t.td,{children:"List of columns to partition the Delta table by."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Overwrite partition predicate"}),(0,r.jsx)(t.td,{children:"Selectively overwrite the data that satisfies the given where clause expression."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Optimize write"}),(0,r.jsx)(t.td,{children:"Whether to optimize the Spark partition sizes based on the actual data."}),(0,r.jsx)(t.td,{children:"false"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"supported-write-modes",children:"Supported write modes"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Write mode"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"error"}),(0,r.jsx)(t.td,{children:"If the data already exists, throw an exception."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"overwrite"}),(0,r.jsxs)(t.td,{children:["If the data already exists, overwrite the data with the contents of the ",(0,r.jsx)(t.code,{children:"DataFrame"}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"append"}),(0,r.jsxs)(t.td,{children:["If the data already exists, append the contents of the ",(0,r.jsx)(t.code,{children:"DataFrame"}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ignore"}),(0,r.jsxs)(t.td,{children:["If the data already exists, do nothing with the contents of the ",(0,r.jsx)(t.code,{children:"DataFrame"}),". ",(0,r.jsx)("br",{}),"This is similar to the ",(0,r.jsx)(t.code,{children:"CREATE TABLE IF NOT EXISTS"})," clause in SQL."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"merge"}),(0,r.jsxs)(t.td,{children:["Use the Delta ",(0,r.jsx)(t.code,{children:"merge"})," command to insert, delete and update data. For more information, see ",(0,r.jsx)(t.a,{href:"#delta-merge",children:"Delta MERGE"}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"scd2 merge"}),(0,r.jsxs)(t.td,{children:["Store and manage the current and historical data over time. For more information, see ",(0,r.jsx)(t.a,{href:"#delta-merge",children:"Delta MERGE"}),"."]})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"target-example",children:"Target Example"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Delta Target Example",src:a(95639).A+"",width:"1140",height:"608"})}),"\n",(0,r.jsx)(t.h3,{id:"target-code",children:"Generated Code"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["To see the generated source code of your project, ",(0,r.jsx)(t.a,{href:"/engineers/project-lifecycle/#review-the-code",children:"switch to the Code view"})," in the project header."]})}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(d.A,{value:"py",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'def writeDelta(spark: SparkSession, in0: DataFrame):\n    return in0.write\\\n            .format("delta")\\\n            .option("optimizeWrite", True)\\\n            .option("mergeSchema", True)\\\n            .option("replaceWhere", "order_dt > \'2022-01-01\'")\\\n            .option("overwriteSchema", True)\\\n            .mode("overwrite")\\\n            .partitionBy("order_dt")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n'})})}),(0,r.jsx)(d.A,{value:"scala",label:"Scala",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object writeDelta {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    in0.write\n        .format("delta")\n        .option("optimizeWrite", True)\n        .option("mergeSchema", True)\n        .option("replaceWhere", "order_dt > \'2022-01-01\'")\n        .option("overwriteSchema", True)\n        .mode("overwrite")\n        .partitionBy("order_dt")\n        .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n'})})})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"delta-merge",children:"Delta MERGE"}),"\n",(0,r.jsxs)(t.p,{children:["You can upsert data from a source ",(0,r.jsx)(t.code,{children:"DataFrame"})," into a target Delta table by using the ",(0,r.jsx)(t.a,{href:"https://docs.delta.io/latest/delta-update.html#upsert-into-a-table-using-merge",children:"MERGE"})," operation. Delta MERGE supports ",(0,r.jsx)(t.code,{children:"Insert"}),", ",(0,r.jsx)(t.code,{children:"Update"}),", and ",(0,r.jsx)(t.code,{children:"Delete"})," operations and modifies records of the most common slowly changing dimension (SCD) cases in one of the following ways:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"#scd1",children:"SCD1"}),": Delta tables do not retain history."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"#scd2",children:"SCD2"}),": Delta tables retain history at the row level."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"#scd3",children:"SCD3"}),": Delta tables retain history at the column level."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"scd1",children:"SCD1"}),"\n",(0,r.jsx)(t.p,{children:"The following lists the properties in an SCD1 MERGE condition where Delta tables do not retain its history."}),"\n",(0,r.jsx)(t.h4,{id:"upsert-properties",children:"Properties"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Default"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Source Alias"}),(0,r.jsxs)(t.td,{children:["Alias to use for the source ",(0,r.jsx)(t.code,{children:"DataFrame"}),"."]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"source"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Target Alias"}),(0,r.jsx)(t.td,{children:"Alias to use for existing target Delta table."}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"taret"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Merge condition"}),(0,r.jsxs)(t.td,{children:["Condition to merge data from source ",(0,r.jsx)(t.code,{children:"DataFrame"})," to target table. ",(0,r.jsx)("br",{}),"Delta can perform an update, delete, or insert action."]}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Matched Update Action"}),(0,r.jsxs)(t.td,{children:["Update the row from your Source gem that exists in your Target gem based on your ",(0,r.jsx)(t.code,{children:"When Matched Update Condition"})," property."]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"update"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Matched Update Condition"}),(0,r.jsxs)(t.td,{children:["Additional condition for updating a row. If you specify a condition, it must evaluate to ",(0,r.jsx)(t.code,{children:"true"})," for the Target gem to update the row."]}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Matched Update Expressions"}),(0,r.jsx)(t.td,{children:"Expressions for setting the values of columns that the Target gem needs to update."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Matched Delete Action"}),(0,r.jsxs)(t.td,{children:["Delete rows if your ",(0,r.jsx)(t.code,{children:"When Matched Delete Condition"})," property and the optional additional condition evaluates to ",(0,r.jsx)(t.code,{children:"true"}),". ",(0,r.jsx)("br",{}),"Delete removes the data from the latest version of the Delta table but does not remove it from the physical storage until you explicitily vacuum the old versions. To learn more, see ",(0,r.jsx)(t.a,{href:"https://docs.delta.io/latest/delta-utility.html#-delta-vacuum",children:"Remove files no longer referenced by a Delta table"})]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"ignore"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Matched Delete Condition"}),(0,r.jsxs)(t.td,{children:["Additional condition for deleting a row. If you specify a condition, it must evaluate to ",(0,r.jsx)(t.code,{children:"true"})," for the Target gem to delete the row."]}),(0,r.jsx)(t.td,{children:"False"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Not Matched Action"}),(0,r.jsxs)(t.td,{children:["Action to perform if the row from your Source gem is not present in your Target gem based on your ",(0,r.jsx)(t.code,{children:"When Not Matched Condition"})," property."]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"insert"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Not Matched Condition"}),(0,r.jsxs)(t.td,{children:["Condition for inserting a row. If you specify a condition, it must evaluate to ",(0,r.jsx)(t.code,{children:"true"})," for the Target gem to insert a new row."]}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"When Not Matched Expressions"}),(0,r.jsx)(t.td,{children:"Expressions for setting the values of columns that the Target gem needs to update."}),(0,r.jsx)(t.td,{children:"None"})]})]})]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"You must set at least one action out of update, delete or insert."}),"\n",(0,r.jsxs)(t.li,{children:["A merge operation fails if multiple rows of the source ",(0,r.jsx)(t.code,{children:"DataFrame"})," matches and the merge attempts to update the same rows of the target Delta table. You can place deduplicate gems before your Target gem if you expect duplicate rows in your Source gem."]}),"\n"]})}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsx)(t.p,{children:"When possible, provide predicates on the partition columns for a partitioned Delta table because predicates can significantly speed up the operations."})}),"\n",(0,r.jsx)(t.h4,{id:"upsert-example",children:"Example"}),"\n",(0,r.jsx)(t.p,{children:"Assume you have the following customers table:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Initial customer table",src:a(96224).A+"",width:"2884",height:"636"})}),"\n",(0,r.jsx)(t.p,{children:"And, you want to make the following updates to the table:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Customer table updates",src:a(47842).A+"",width:"2886",height:"530"})}),"\n",(0,r.jsx)(t.p,{children:"The following shows the output and configurations for an SCD1 merge:"}),"\n",(0,r.jsx)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"},children:(0,r.jsx)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"},children:(0,r.jsx)("iframe",{src:"https://user-images.githubusercontent.com/103921419/173252757-0a1165f0-68e2-41ca-b6eb-58da51cb76d1.mp4",title:"SCD3",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"})})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.h4,{id:"upsert-code",children:"Generated Code"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["To see the generated source code of your project, ",(0,r.jsx)(t.a,{href:"/engineers/project-lifecycle/#review-the-code",children:"switch to the Code view"})," in the project header."]})}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(d.A,{value:"py",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'def writeDeltaMerge(spark: SparkSession, in0: DataFrame):\n    from delta.tables import DeltaTable, DeltaMergeBuilder\n\n    if DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1"):\n        DeltaTable\\\n            .forPath(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\\\n            .alias("target")\\\n            .merge(in0.alias("source"), (col("source.customer_id") == col("target.customer_id")))\\\n            .whenMatchedUpdateAll()\\\n            .whenNotMatchedInsertAll()\\\n            .execute()\n    else:\n        in0.write\\\n            .format("delta")\\\n            .mode("overwrite")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\n'})})}),(0,r.jsx)(d.A,{value:"scala",label:"Scala",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object writeDeltaMerge {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    import _root_.io.delta.tables._\n    if (DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")) {\n        DeltaTable\n            .forPath(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\n            .as("target")\n            .merge(in0.as("source"), (col("source.customer_id") === col("target.customer_id")))\n            .whenMatched()\n            .updateAll()\n            .whenNotMatched()\n            .insertAll()\n            .execute()\n    }\n    else {\n        in0.write\n            .format("delta")\n            .mode("overwrite")\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd1")\n    }\n  }\n\n}\n'})})})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"scd2",children:"SCD2"}),"\n",(0,r.jsx)(t.p,{children:"The following lists the properties in an SCD2 MERGE condition where Delta tables retain history at the row level."}),"\n",(0,r.jsx)(t.h4,{id:"scd2-properties",children:"Parameters"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Default"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Key Columns"}),(0,r.jsx)(t.td,{children:"List of key columns to remain constant."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Historic Columns"}),(0,r.jsx)(t.td,{children:"List of columns to change over time and maintain its history."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"From time column"}),(0,r.jsx)(t.td,{children:"Time from which a particular row is valid."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"To time column"}),(0,r.jsx)(t.td,{children:"Time till which a particular row is not valid anymore."}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Name of the column used as min/old-value flag"}),(0,r.jsxs)(t.td,{children:["Column to store the flag as ",(0,r.jsx)(t.code,{children:"true"})," for the first entry of a particular key."]}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Name of the column used as max/latest flag"}),(0,r.jsxs)(t.td,{children:["Column to store the flag as ",(0,r.jsx)(t.code,{children:"true"})," for the last entry of a particular key."]}),(0,r.jsx)(t.td,{children:"None"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Flag values"}),(0,r.jsxs)(t.td,{children:["Format of the min and max flag. ",(0,r.jsx)("br",{})," Possible values are: ",(0,r.jsx)(t.code,{children:"true/false"}),", or ",(0,r.jsx)(t.code,{children:"0/1"}),"."]}),(0,r.jsx)(t.td,{children:"None"})]})]})]}),"\n",(0,r.jsx)(t.h4,{id:"scd2-example",children:"Example"}),"\n",(0,r.jsxs)(t.p,{children:["Continuing from ",(0,r.jsx)(t.a,{href:"#upsert-example",children:"the SCD1 example"}),", you can use the Delta log to capture the historical ",(0,r.jsx)(t.code,{children:"customer_zip_code"})," at the row-level.\nThe following shows the output and configurations for an SCD2 merge:"]}),"\n",(0,r.jsx)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"},children:(0,r.jsx)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"},children:(0,r.jsx)("iframe",{src:"https://user-images.githubusercontent.com/103921419/173252742-00930084-b3b3-4b8a-b5bb-59f39b74792b.mp4",title:"SCD3",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"})})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.h4,{id:"scd2-code",children:"Generated Code"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["To see the generated source code of your project, ",(0,r.jsx)(t.a,{href:"/engineers/project-lifecycle/#review-the-code",children:"switch to the Code view"})," in the project header."]})}),"\n",(0,r.jsxs)(l.A,{children:[(0,r.jsx)(d.A,{value:"py",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-py",children:'def writeDeltaSCD2(spark: SparkSession, in0: DataFrame):\n    from delta.tables import DeltaTable, DeltaMergeBuilder\n\n    if DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"):\n        existingTable = DeltaTable.forPath(\n            spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n        )\n        updatesDF = in0.withColumn("minFlag", lit("true")).withColumn(\n            "maxFlag", lit("true")\n        )\n        existingDF = existingTable.toDF()\n        updateColumns = updatesDF.columns\n        stagedUpdatesDF = (\n            updatesDF.join(existingDF, ["customer_id"])\n            .where(\n                (\n                    (existingDF["maxFlag"] == lit("true"))\n                    & (\n                        (\n                            (\n                                existingDF["customer_zip_code"]\n                                != updatesDF["customer_zip_code"]\n                            )\n                            | (\n                                existingDF["customer_city"]\n                                != updatesDF["customer_city"]\n                            )\n                        )\n                        | (existingDF["customer_state"] != updatesDF["customer_state"])\n                    )\n                )\n            )\n            .select(*[updatesDF[val] for val in updateColumns])\n            .withColumn("minFlag", lit("false"))\n            .withColumn("mergeKey", lit(None))\n            .union(updatesDF.withColumn("mergeKey", concat("customer_id")))\n        )\n        existingTable.alias("existingTable").merge(\n            stagedUpdatesDF.alias("staged_updates"),\n            concat(existingDF["customer_id"]) == stagedUpdatesDF["mergeKey"],\n        ).whenMatchedUpdate(\n            condition=(\n                (existingDF["maxFlag"] == lit("true"))\n                & (\n                    (\n                        (\n                            existingDF["customer_zip_code"]\n                            != stagedUpdatesDF["customer_zip_code"]\n                        )\n                        | (\n                            existingDF["customer_city"]\n                            != stagedUpdatesDF["customer_city"]\n                        )\n                    )\n                    | (\n                        existingDF["customer_state"]\n                        != stagedUpdatesDF["customer_state"]\n                    )\n                )\n            ),\n            set={"maxFlag": "false", "end_date": "staged_updates.updated_dt"},\n        )\\\n        .whenNotMatchedInsertAll()\\\n        .execute()\n    else:\n        in0.write\\\n            .format("delta")\\\n            .mode("overwrite")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2")\n'})})}),(0,r.jsx)(d.A,{value:"scala",label:"Scala",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-scala",children:'object writeDeltaSCD2 {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    import _root_.io.delta.tables._\n    if (\n      DeltaTable.isDeltaTable(\n        spark,\n        "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n      )\n    ) {\n      val updatesDF = in\n        .withColumn("minFlag", lit("true"))\n        .withColumn("maxFlag", lit("true"))\n      val existingTable: DeltaTable = DeltaTable.forPath(\n        spark,\n        "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n      )\n      val existingDF: DataFrame = existingTable.toDF\n      val stagedUpdatesDF = updatesDF\n        .join(existingDF, List("customer_id"))\n        .where(\n          existingDF.col("maxFlag") === lit("true") && List(\n            existingDF.col("customer_zip_code") =!= updatesDF\n              .col("customer_zip_code"),\n            existingDF.col("customer_city") =!= updatesDF\n              .col("customer_city"),\n            existingDF.col("customer_state") =!= updatesDF\n              .col("customer_state")\n          ).reduce((c1, c2) => c1 || c2)\n        )\n        .select(updatesDF.columns.map(x => updatesDF.col(x)): _*)\n        .withColumn("minFlag", lit("false"))\n        .withColumn("mergeKey", lit(null))\n        .union(updatesDF.withColumn("mergeKey", concat(col("customer_id"))))\n      existingTable\n        .as("existingTable")\n        .merge(\n          stagedUpdatesDF.as("staged_updates"),\n          concat(existingDF.col("customer_id")) === stagedUpdatesDF(\n            "mergeKey"\n          )\n        )\n        .whenMatched(\n          existingDF.col("maxFlag") === lit("true") && List(\n            existingDF.col("customer_zip_code") =!= stagedUpdatesDF\n              .col("customer_zip_code"),\n            existingDF.col("customer_city") =!= stagedUpdatesDF\n              .col("customer_city"),\n            existingDF.col("customer_state") =!= stagedUpdatesDF\n              .col("customer_state")\n          ).reduce((c1, c2) => c1 || c2)\n        )\n        .updateExpr(\n          Map("maxFlag" \u2192 "false", "end_date" \u2192 "staged_updates.updated_dt")\n        )\n        .whenNotMatched()\n        .insertAll()\n        .execute()\n    } else {\n      in0.write\n        .format("delta")\n        .mode("overwrite")\n        .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n    }\n\n  }\n\n}\n'})})})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"scd3",children:"SCD3"}),"\n",(0,r.jsxs)(t.p,{children:["Continuing from ",(0,r.jsx)(t.a,{href:"#scd2-example",children:"the SCD2 example"}),", you use the Delta log to capture the historical ",(0,r.jsx)(t.code,{children:"customer_zip_code"})," at the column-level.\nThe following shows the output and configurations for an SCD3 merge:"]}),"\n",(0,r.jsx)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"},children:(0,r.jsx)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"},children:(0,r.jsx)("iframe",{src:"https://user-images.githubusercontent.com/103921419/173252728-8924f0fb-6e81-44b7-9c39-17ba1d8f4d4c.mp4",title:"SCD3",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"})})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["To see the generated source code of your project, ",(0,r.jsx)(t.a,{href:"/engineers/project-lifecycle/#review-the-code",children:"switch to the Code view"})," in the project header."]})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["To learn more about how Prophecy uses the Delta file type, see ",(0,r.jsx)(t.a,{href:"https://www.prophecy.io/blog/prophecy-with-delta-making-data-lakehouse-easier",children:"Prophecy with Delta \u2014 making data lakehouses easier"}),"."]})})]})}function m(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},47842:(e,t,a)=>{a.d(t,{A:()=>s});const s=a.p+"assets/images/delta_customers_updates_eg1-2ebf4ee81ff2c6c649073211bec6d9ea.png"},49235:(e,t,a)=>{a.d(t,{A:()=>r});a(96540);var s=a(74848);function r(e){return(0,s.jsxs)("div",{children:[e.python_package_name&&e.python_package_version&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/extensibility/package-hub/",children:(0,s.jsxs)("span",{className:"badge-dependency",children:[(0,s.jsx)("span",{className:"left",children:e.python_package_name}),(0,s.jsx)("span",{className:"right",children:e.python_package_version})]})}),e.scala_package_name&&e.scala_package_version&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/extensibility/package-hub/",children:(0,s.jsxs)("span",{className:"badge-dependency",children:[(0,s.jsx)("span",{className:"left",children:e.scala_package_name}),(0,s.jsx)("span",{className:"right",children:e.scala_package_version})]})}),e.python_lib&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/extensibility/dependencies/prophecy-libraries",children:(0,s.jsxs)("span",{className:"badge-dependency",children:[(0,s.jsx)("span",{className:"left",children:"ProphecyLibsPython"}),(0,s.jsx)("span",{className:"right",children:e.python_lib})]})}),e.scala_lib&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/extensibility/dependencies/prophecy-libraries",children:(0,s.jsxs)("span",{className:"badge-dependency",children:[(0,s.jsx)("span",{className:"left",children:"ProphecyLibsScala"}),(0,s.jsx)("span",{className:"right",children:e.scala_lib})]})}),e.uc_single&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/administration/fabrics/Spark-fabrics/databricks/",children:(0,s.jsxs)("span",{className:"badge-spark",children:[(0,s.jsx)("span",{className:"left",children:"Databricks UC Single Cluster"}),(0,s.jsx)("span",{className:"right",children:e.uc_single})]})}),e.uc_shared&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/administration/fabrics/Spark-fabrics/databricks/ucshared",children:(0,s.jsxs)("span",{className:"badge-spark",children:[(0,s.jsx)("span",{className:"left",children:"Databricks UC Shared"}),(0,s.jsx)("span",{className:"right",children:e.uc_shared})]})}),e.livy&&(0,s.jsx)("a",{href:"https://docs.prophecy.io/administration/fabrics/Spark-fabrics/livy",children:(0,s.jsxs)("span",{className:"badge-spark",children:[(0,s.jsx)("span",{className:"left",children:"Livy"}),(0,s.jsx)("span",{className:"right",children:e.livy})]})}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{})]})}},65537:(e,t,a)=>{a.d(t,{A:()=>D});var s=a(96540),r=a(18215),n=a(65627),i=a(56347),l=a(50372),d=a(30604),o=a(11861),c=a(78749);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:a}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:a,attributes:s,default:r}}=e;return{value:t,label:a,attributes:s,default:r}}))}(a);return function(e){const t=(0,o.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function u(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:a}=e;const r=(0,i.W6)(),n=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,d.aZ)(n),(0,s.useCallback)((e=>{if(!n)return;const t=new URLSearchParams(r.location.search);t.set(n,e),r.replace({...r.location,search:t.toString()})}),[n,r])]}function x(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,n=p(e),[i,d]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!u({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=a.find((e=>e.default))??a[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:n}))),[o,h]=m({queryString:a,groupId:r}),[x,j]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,n]=(0,c.Dv)(a);return[r,(0,s.useCallback)((e=>{a&&n.set(e)}),[a,n])]}({groupId:r}),g=(()=>{const e=o??x;return u({value:e,tabValues:n})?e:null})();(0,l.A)((()=>{g&&d(g)}),[g]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!u({value:e,tabValues:n}))throw new Error(`Can't select invalid tab value=${e}`);d(e),h(e),j(e)}),[h,j,n]),tabValues:n}}var j=a(9136);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=a(74848);function b(e){let{className:t,block:a,selectedValue:s,selectValue:i,tabValues:l}=e;const d=[],{blockElementScrollPositionUntilNextRender:o}=(0,n.a_)(),c=e=>{const t=e.currentTarget,a=d.indexOf(t),r=l[a].value;r!==s&&(o(t),i(r))},h=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=d.indexOf(e.currentTarget)+1;t=d[a]??d[0];break}case"ArrowLeft":{const a=d.indexOf(e.currentTarget)-1;t=d[a]??d[d.length-1];break}}t?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":a},t),children:l.map((e=>{let{value:t,label:a,attributes:n}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>{d.push(e)},onKeyDown:h,onClick:c,...n,className:(0,r.A)("tabs__item",g.tabItem,n?.className,{"tabs__item--active":s===t}),children:a??t},t)}))})}function v(e){let{lazy:t,children:a,selectedValue:n}=e;const i=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===n));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==n})))})}function y(e){const t=x(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,f.jsx)(b,{...t,...e}),(0,f.jsx)(v,{...t,...e})]})}function D(e){const t=(0,j.A)();return(0,f.jsx)(y,{...e,children:h(e.children)},String(t))}},79329:(e,t,a)=>{a.d(t,{A:()=>i});a(96540);var s=a(18215);const r={tabItem:"tabItem_Ymn6"};var n=a(74848);function i(e){let{children:t,hidden:a,className:i}=e;return(0,n.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,i),hidden:a,children:t})}},83607:(e,t,a)=>{a.d(t,{A:()=>s});const s=a.p+"assets/images/delta_source_eg-a9bacfae161d215a8ceeec0330f206b3.gif"},95639:(e,t,a)=>{a.d(t,{A:()=>s});const s=a.p+"assets/images/delta_target_eg-c6f697a3f02a7267907d97f5556e1468.gif"},96224:(e,t,a)=>{a.d(t,{A:()=>s});const s=a.p+"assets/images/delta_customers_initial_eg1-bd4fa7277b1fe2accbe931d2d51ed46a.png"}}]);