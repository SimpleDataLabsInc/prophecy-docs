"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[26699],{3897:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/variant-edit-schema-c34b2b0d6d41c85e241e355c0be408b4.png"},23165:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/variant-add-column-b2a643560e3b0a89167186a5f4876379.png"},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},85955:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"analysts/development/gems/visual-expression-builder/variant-schema","title":"Variant schema","description":"About variant schema","source":"@site/docs/analysts/development/gems/visual-expression-builder/variant-schema.md","sourceDirName":"analysts/development/gems/visual-expression-builder","slug":"/analysts/variant-schema","permalink":"/analysts/variant-schema","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"concept","permalink":"/tags/concept"},{"inline":true,"label":"variant","permalink":"/tags/variant"},{"inline":true,"label":"sql","permalink":"/tags/sql"}],"version":"current","frontMatter":{"title":"Variant schema","id":"variant-schema","slug":"/analysts/variant-schema","description":"About variant schema","tags":["concept","variant","sql"]},"sidebar":"mySidebar","previous":{"title":"Use visual expressions","permalink":"/analysts/use-visual-expression-builder"},"next":{"title":"Connections","permalink":"/analysts/connections"}}');var s=t(74848),i=t(28453);const r={title:"Variant schema",id:"variant-schema",slug:"/analysts/variant-schema",description:"About variant schema",tags:["concept","variant","sql"]},c=void 0,o={},l=[{value:"Inferring the variant schema",id:"inferring-the-variant-schema",level:2},{value:"Editing the variant schema",id:"editing-the-variant-schema",level:3},{value:"Variant sampling setting",id:"variant-sampling-setting",level:2},{value:"Adding a nested column",id:"adding-a-nested-column",level:2},{value:"Default casting",id:"default-casting",level:3}];function h(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"You can use Prophecy to convert your variant schemas into flat, structured formats to make them easier to understand and use for analytics. This is available for when you want to determine the variant schema of your Snowflake array or object."}),"\n",(0,s.jsx)(n.p,{children:"Using the variant schema functionality, you can do the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Infer the variant schema"}),"\n",(0,s.jsx)(n.li,{children:"Configure the parsing limit for inferring the column structure"}),"\n",(0,s.jsx)(n.li,{children:"Use a nested column inside of the Visual Expression Builder"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"inferring-the-variant-schema",children:"Inferring the variant schema"}),"\n",(0,s.jsx)(n.p,{children:"Variant schemas are not stored within the table definition and can vary for each row, making them difficult to infer and use. Fortunately, you don't have to infer the schema yourself. You can use the column selector inside of your gems to automatically infer the variant schema, explore the multi-type variant structure, and later select a nested column to use in your transformations."}),"\n",(0,s.jsx)(n.p,{children:"To automatically infer the variant schema, start by opening a gem that uses a variant column input."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Select the variant column, and click ",(0,s.jsx)(n.strong,{children:"Infer Schema"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Prophecy will automatically detect and identify the variant types in your input data."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Schema and column selector",src:t(96693).A+"",width:"2620",height:"1507"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"The inferred schema is cached so that you can use it again in the future whenever you reopen the model, gem, or another gem connected to the same input port. Check the bottom of the column selector to see the last time the variant schema was inferred."}),(0,s.jsxs)(n.p,{children:["To refresh the schema, simply click ",(0,s.jsx)(n.strong,{children:"Infer Schema"})," again."]})]}),"\n",(0,s.jsx)(n.h3,{id:"editing-the-variant-schema",children:"Editing the variant schema"}),"\n",(0,s.jsxs)(n.p,{children:["After you infer the schema, you can click ",(0,s.jsx)(n.strong,{children:"Edit Schema"})," to view the variant schema and make edits to it. Use the Type dropdowns to manually choose the data type of each nested schema."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Edit schema view",src:t(3897).A+"",width:"2620",height:"1507"})}),"\n",(0,s.jsx)(n.p,{children:"Editing the variant schema is useful in cases where not all of the schema cases were covered while sampling the records."}),"\n",(0,s.jsx)(n.h2,{id:"variant-sampling-setting",children:"Variant sampling setting"}),"\n",(0,s.jsx)(n.p,{children:"When Prophecy infers the variant schema, it samples the records to identify all potential iterations of keys and values within the schema."}),"\n",(0,s.jsxs)(n.p,{children:["The default number of records that Prophecy parses to understand the nested data schema is 100. You can update this limit under the Development Settings, which you can navigate to by clicking ",(0,s.jsx)(n.strong,{children:"... > Development Settings"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Variant sampling setting",src:t(98197).A+"",width:"2812",height:"899"})}),"\n",(0,s.jsx)(n.p,{children:"We recommend that you increase the limit for small structures, or decrease it for larger ones."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This setting does not rely on the ratio of the data since that would require a complete count of the data records."})}),"\n",(0,s.jsx)(n.h2,{id:"adding-a-nested-column",children:"Adding a nested column"}),"\n",(0,s.jsxs)(n.p,{children:["With in the column selector, you can add a nested column by clicking ",(0,s.jsx)(n.strong,{children:"Add Column"})," next to the input field name."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Add column",src:t(23165).A+"",width:"2620",height:"1507"})}),"\n",(0,s.jsx)(n.p,{children:"When adding a column nested within a variant, the output column name, expression, and data type are automatically generated according to the following rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Column name: The column name matches the input field name, and is prefixed with the parent field path. If there's a conflict, Prophecy appends numbers starting with ",(0,s.jsx)(n.code,{children:"_0"})," until it becomes unique."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if the column name ",(0,s.jsx)(n.code,{children:"customers_name"})," already exists, the new field might be named ",(0,s.jsx)(n.code,{children:"customers_name_0"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Expression: The expression represents the full path to the selected field, and uses existing flattened subpaths."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Data type: The data type is automatically ",(0,s.jsx)(n.code,{children:"CAST"})," to the closest inferred type."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"default-casting",children:"Default casting"}),"\n",(0,s.jsxs)(n.p,{children:["Prophecy automatically adds a ",(0,s.jsx)(n.code,{children:"CAST"})," to any column you add from a nested type. By default, the column is cast using the standard ",(0,s.jsx)(n.code,{children:"CAST(x AS y)"})," syntax."]}),"\n",(0,s.jsx)(n.p,{children:"In some cases, a path within a variant may hold different value types across rows. For instance, consider a dataset where each row\u2019s value key contains different data types, such as integer, object, and boolean."}),"\n",(0,s.jsxs)(n.p,{children:["Prophecy supports this scenario by presenting each detected data type for a given key, array, or object as a separate item in the column selector. When you add one of those columns to the expression, we use explicit casting, which may error out if the cast is not possible. You can change this behavior by using ",(0,s.jsx)(n.code,{children:"TRY_CAST"}),", which returns ",(0,s.jsx)(n.code,{children:"null"})," if the cast is not possible."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},96693:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/variant-infer-schema-77134126e589a14820f81792a352645d.png"},98197:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/variant-sampling-setting-90f03ebaac15557b12a806a246d9ee87.png"}}]);