"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[10722],{15680:(e,t,a)=>{a.d(t,{xA:()=>g,yg:()=>y});var r=a(96540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},g=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),d=p(a),m=n,y=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return a?r.createElement(y,i(i({ref:t},g),{},{components:a})):r.createElement(y,i({ref:t},g))}));function y(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:n,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},19365:(e,t,a)=>{a.d(t,{A:()=>i});var r=a(96540),n=a(20053);const l={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:a,className:i}=e;return r.createElement("div",{role:"tabpanel",className:(0,n.A)(l.tabItem,i),hidden:a},t)}},11470:(e,t,a)=>{a.d(t,{A:()=>w});var r=a(58168),n=a(96540),l=a(20053),i=a(23104),o=a(56347),s=a(57485),p=a(31682),g=a(89466);function d(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:r,default:n}}=e;return{value:t,label:a,attributes:r,default:n}}))}function u(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??d(a);return function(e){const t=(0,p.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function y(e){let{queryString:t=!1,groupId:a}=e;const r=(0,o.W6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s.aZ)(l),(0,n.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(r.location.search);t.set(l,e),r.replace({...r.location,search:t.toString()})}),[l,r])]}function c(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,l=u(e),[i,o]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=a.find((e=>e.default))??a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:l}))),[s,p]=y({queryString:a,groupId:r}),[d,c]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,l]=(0,g.Dv)(a);return[r,(0,n.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:r}),N=(()=>{const e=s??d;return m({value:e,tabValues:l})?e:null})();(0,n.useLayoutEffect)((()=>{N&&o(N)}),[N]);return{selectedValue:i,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);o(e),p(e),c(e)}),[p,c,l]),tabValues:l}}var N=a(92303);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:a,selectedValue:o,selectValue:s,tabValues:p}=e;const g=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.a_)(),u=e=>{const t=e.currentTarget,a=g.indexOf(t),r=p[a].value;r!==o&&(d(t),s(r))},m=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const a=g.indexOf(e.currentTarget)+1;t=g[a]??g[0];break}case"ArrowLeft":{const a=g.indexOf(e.currentTarget)-1;t=g[a]??g[g.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":a},t)},p.map((e=>{let{value:t,label:a,attributes:i}=e;return n.createElement("li",(0,r.A)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>g.push(e),onKeyDown:m,onClick:u},i,{className:(0,l.A)("tabs__item",h.tabItem,i?.className,{"tabs__item--active":o===t})}),a??t)})))}function b(e){let{lazy:t,children:a,selectedValue:r}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function v(e){const t=c(e);return n.createElement("div",{className:(0,l.A)("tabs-container",h.tabList)},n.createElement(f,(0,r.A)({},e,t)),n.createElement(b,(0,r.A)({},e,t)))}function w(e){const t=(0,N.A)();return n.createElement(v,(0,r.A)({key:String(t)},e))}},50728:(e,t,a)=>{a.d(t,{A:()=>n});var r=a(96540);function n(e){return r.createElement("div",null,e.python_package_name&&e.python_package_version&&r.createElement("a",{href:"https://docs.prophecy.io/extensibility/package-hub/"},r.createElement("span",{className:"badge-dependency"},r.createElement("span",{className:"left"},e.python_package_name),r.createElement("span",{className:"right"},e.python_package_version))),e.scala_package_name&&e.scala_package_version&&r.createElement("a",{href:"https://docs.prophecy.io/extensibility/package-hub/"},r.createElement("span",{className:"badge-dependency"},r.createElement("span",{className:"left"},e.scala_package_name),r.createElement("span",{className:"right"},e.scala_package_version))),e.python_lib&&r.createElement("a",{href:"https://docs.prophecy.io/extensibility/dependencies/prophecy-libraries"},r.createElement("span",{className:"badge-dependency"},r.createElement("span",{className:"left"},"ProphecyLibsPython"),r.createElement("span",{className:"right"},e.python_lib))),e.scala_lib&&r.createElement("a",{href:"https://docs.prophecy.io/extensibility/dependencies/prophecy-libraries"},r.createElement("span",{className:"badge-dependency"},r.createElement("span",{className:"left"},"ProphecyLibsScala"),r.createElement("span",{className:"right"},e.scala_lib))),e.uc_single&&r.createElement("a",{href:"https://docs.prophecy.io/administration/Spark-fabrics/databricks/"},r.createElement("span",{className:"badge-spark"},r.createElement("span",{className:"left"},"Databricks UC Single Cluster"),r.createElement("span",{className:"right"},e.uc_single))),e.uc_shared&&r.createElement("a",{href:"https://docs.prophecy.io/administration/Spark-fabrics/databricks/ucshared"},r.createElement("span",{className:"badge-spark"},r.createElement("span",{className:"left"},"Databricks UC Shared"),r.createElement("span",{className:"right"},e.uc_shared))),e.livy&&r.createElement("a",{href:"https://docs.prophecy.io/administration/Spark-fabrics/livy"},r.createElement("span",{className:"badge-spark"},r.createElement("span",{className:"left"},"Livy"),r.createElement("span",{className:"right"},e.livy))),r.createElement("br",null),r.createElement("br",null))}},68851:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>c,frontMatter:()=>s,metadata:()=>g,toc:()=>u});var r=a(58168),n=(a(96540),a(15680)),l=a(50728),i=a(11470),o=a(19365);const s={title:"XLSX (Excel)",id:"xlsx",description:"Parameters and properties to read from and write too XLSX (Excel) files",tags:["gems","file","xlsx"]},p=void 0,g={unversionedId:"Spark/gems/source-target/file/xlsx",id:"Spark/gems/source-target/file/xlsx",title:"XLSX (Excel)",description:"Parameters and properties to read from and write too XLSX (Excel) files",source:"@site/docs/Spark/gems/source-target/file/xlsx.md",sourceDirName:"Spark/gems/source-target/file",slug:"/Spark/gems/source-target/file/xlsx",permalink:"/Spark/gems/source-target/file/xlsx",draft:!1,tags:[{label:"gems",permalink:"/tags/gems"},{label:"file",permalink:"/tags/file"},{label:"xlsx",permalink:"/tags/xlsx"}],version:"current",frontMatter:{title:"XLSX (Excel)",id:"xlsx",description:"Parameters and properties to read from and write too XLSX (Excel) files",tags:["gems","file","xlsx"]},sidebar:"mySidebar",previous:{title:"Upload files",permalink:"/Spark/gems/source-target/file/upload-file"},next:{title:"XML",permalink:"/Spark/gems/source-target/file/xml"}},d={},u=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Source",id:"source",level:2},{value:"Source properties",id:"source-properties",level:3},{value:"Supported parse modes",id:"supported-parse-modes",level:3},{value:"Target",id:"target",level:2},{value:"Target properties",id:"target-properties",level:3},{value:"Supported write modes",id:"supported-write-modes",level:3},{value:"Writing a single output file",id:"writing-a-single-output-file",level:2},{value:"Example code",id:"example-code",level:2}],m={toc:u},y="wrapper";function c(e){let{components:t,...s}=e;return(0,n.yg)(y,(0,r.A)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,n.yg)(l.A,{python_package_name:"ProphecySparkBasicsPython",python_package_version:"0.0.1+",scala_package_name:"ProphecySparkBasicsScala",scala_package_version:"0.0.1+",scala_lib:"",python_lib:"",uc_single:"14.3+",uc_shared:"Not Supported",livy:"Not Supported",mdxType:"Requirements"}),(0,n.yg)("p",null,"The XLSX (Excel) file type:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"Is in XML format, which is easier for data access, manipulation, and compatibility with various software applications."),(0,n.yg)("li",{parentName:"ul"},"Offers password protection options, which allow users to secure sensitive data.")),(0,n.yg)("h2",{id:"prerequisites"},"Prerequisites"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"If you receive an error about the ",(0,n.yg)("inlineCode",{parentName:"p"},"excel")," format not being available you must add ",(0,n.yg)("inlineCode",{parentName:"p"},"spark-excel")," library as a dependency.")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"To add the Maven coordinate ",(0,n.yg)("inlineCode",{parentName:"p"},"com.crealytics:spark-excel_2.12:3.5.1_0.20.4")," to your pipeline, see ",(0,n.yg)("a",{parentName:"p",href:"/extensibility/dependencies/spark-dependencies"},"Spark dependencies"),"."))),(0,n.yg)("h2",{id:"parameters"},"Parameters"),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Parameter"),(0,n.yg)("th",{parentName:"tr",align:null},"Tab"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Location"),(0,n.yg)("td",{parentName:"tr",align:null},"Location"),(0,n.yg)("td",{parentName:"tr",align:null},"File path to read from or write to the XLSX file.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Schema"),(0,n.yg)("td",{parentName:"tr",align:null},"Properties"),(0,n.yg)("td",{parentName:"tr",align:null},"Schema to apply on the loaded data.",(0,n.yg)("br",null),"In the Source gem, you can define or edit the schema visually or in JSON code.",(0,n.yg)("br",null),"In the Target gem, you can view the schema visually or as JSON code.")))),(0,n.yg)("h2",{id:"source"},"Source"),(0,n.yg)("p",null,"The Source gem reads data from XLSX files and allows you to optionally specify the following additional properties."),(0,n.yg)("h3",{id:"source-properties"},"Source properties"),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Property name"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"),(0,n.yg)("th",{parentName:"tr",align:null},"Default"),(0,n.yg)("th",{parentName:"tr",align:null}))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Enforce Schema"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to use the schema you define."),(0,n.yg)("td",{parentName:"tr",align:null},"false"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Header"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to read the first line as a header."),(0,n.yg)("td",{parentName:"tr",align:null},"true"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Description"),(0,n.yg)("td",{parentName:"tr",align:null},"Description of your dataset."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Data Address"),(0,n.yg)("td",{parentName:"tr",align:null},"Location to read data addresses from. To learn more, see ",(0,n.yg)("a",{parentName:"td",href:"https://github.com/crealytics/spark-excel#data-addresses"},"Data Addresses"),"."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"A1")," (Everything)"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Column Name of Corrupt Record"),(0,n.yg)("td",{parentName:"tr",align:null},"Rename the field the PERMISSIVE mode creates to store malformed data."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"_corrupt_records")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Column Name of Row Number"),(0,n.yg)("td",{parentName:"tr",align:null},"Name of the column to create using the original row number."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Date Format"),(0,n.yg)("td",{parentName:"tr",align:null},"String that indicates a date format."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"yyyy-MM-dd")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Excerpt Size"),(0,n.yg)("td",{parentName:"tr",align:null},"Excerpt Size."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"File Extension"),(0,n.yg)("td",{parentName:"tr",align:null},"Extension of the file to read in."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"xlsx")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Ignore After Header"),(0,n.yg)("td",{parentName:"tr",align:null},"Number of rows to ignore after the header."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Ignore leading white spaces from values"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to skip the leading whitespaces from values the Source gem reads."),(0,n.yg)("td",{parentName:"tr",align:null},"false"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Ignore trailing white spaces from values"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to skip the trailing whitespaces from values the Source gem reads."),(0,n.yg)("td",{parentName:"tr",align:null},"false"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Infer Schema"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to automatically infer the input schema from the data. This requires one extra pass over the data. ",(0,n.yg)("br",null),(0,n.yg)("br",null),(0,n.yg)("strong",{parentName:"td"},"Note:")," The ",(0,n.yg)("inlineCode",{parentName:"td"},"spark-excel")," library provides this setting and is different than the ",(0,n.yg)("inlineCode",{parentName:"td"},"Infer Schema")," button in the Prophecy UI. Both should provide the same results."),(0,n.yg)("td",{parentName:"tr",align:null},"false"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Locale"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets a locale as language tag in IETF BCP 47 format."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"en-US")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"NaN Value"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets the string representation of a non-number value."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"NaN")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Negative Infinite value"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets the string representation of a negative infinity value."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"-Inf")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Null Value"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets the string representation of a null value."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Parse Mode"),(0,n.yg)("td",{parentName:"tr",align:null},"How to handle corrupt data. ",(0,n.yg)("br",null),"For a list of the possible values, see ",(0,n.yg)("a",{parentName:"td",href:"#supported-parse-modes"},"Supported parse modes"),"."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"Permissive")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Positive Infinite value"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets the string representation of a positive infinity value."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"Inf")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Sampling Ratio"),(0,n.yg)("td",{parentName:"tr",align:null},"Defines a fraction of rows to use for schema inferring"),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"1.0")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Timestamp Format"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets the string that indicates a timestamp format."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"yyyy-MM-dd'T'HH:mm:ss[.SSS][XXX]")),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Use Null for Error Cells"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to use null for cells with errors."),(0,n.yg)("td",{parentName:"tr",align:null},"false"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Workbook Password"),(0,n.yg)("td",{parentName:"tr",align:null},"Password to secure your workbook."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Time Zone ID"),(0,n.yg)("td",{parentName:"tr",align:null},"Timezone ID for the ",(0,n.yg)("inlineCode",{parentName:"td"},"Date")," and ",(0,n.yg)("inlineCode",{parentName:"td"},"Timestamp")," from the IANA Time Zone Database.",(0,n.yg)("br",null),(0,n.yg)("strong",{parentName:"td"},"Note:")," For a list of valid values, see ",(0,n.yg)("a",{parentName:"td",href:"https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html"},"Class ZoneId"),"."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Temporary file threshold"),(0,n.yg)("td",{parentName:"tr",align:null},"When the Source gem should start writing data to temporary files on disk instead of keeping it in memory."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Maximum rows in memory"),(0,n.yg)("td",{parentName:"tr",align:null},"Maximum amount of rows to have in memory."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Maximum byte array size"),(0,n.yg)("td",{parentName:"tr",align:null},"Maximum size of your array."),(0,n.yg)("td",{parentName:"tr",align:null},"None"),(0,n.yg)("td",{parentName:"tr",align:null})))),(0,n.yg)("h3",{id:"supported-parse-modes"},"Supported parse modes"),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Mode"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Permissive"),(0,n.yg)("td",{parentName:"tr",align:null},"Put the malformed string into the corrupt records column, and set the malformed fields to null.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Drop Malformed"),(0,n.yg)("td",{parentName:"tr",align:null},"Ignore the entire corrupted record. This mode is not supported in the CSV built-in functions.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Fail Fast"),(0,n.yg)("td",{parentName:"tr",align:null},"Throw an exception when it meets a corrupted record.")))),(0,n.yg)("h2",{id:"target"},"Target"),(0,n.yg)("p",null,"The Target gem writes data to XLSX files and allows you to optionally specify the following additional properties."),(0,n.yg)("h3",{id:"target-properties"},"Target properties"),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Property name"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"),(0,n.yg)("th",{parentName:"tr",align:null},"Default"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Data Address"),(0,n.yg)("td",{parentName:"tr",align:null},"Location to write data addresses to. To learn more, see ",(0,n.yg)("a",{parentName:"td",href:"https://github.com/crealytics/spark-excel#data-addresses"},"Data Addresses"),"."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"A1"))),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"File Extension"),(0,n.yg)("td",{parentName:"tr",align:null},"File extension of the file to write to."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"xlsx"))),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Header"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to write a header to the file."),(0,n.yg)("td",{parentName:"tr",align:null},"true")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Locale"),(0,n.yg)("td",{parentName:"tr",align:null},"Sets a locale as language tag in IETF BCP 47 format."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"en-US"))),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Date Format"),(0,n.yg)("td",{parentName:"tr",align:null},"String that indicates a date format."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"yyyy-MM-dd"))),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Use Plain Number Format"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to format the cells without rounding and scientific notations."),(0,n.yg)("td",{parentName:"tr",align:null},"false")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Workbook Password"),(0,n.yg)("td",{parentName:"tr",align:null},"Password to secure your workbook."),(0,n.yg)("td",{parentName:"tr",align:null},"None")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Write Mode"),(0,n.yg)("td",{parentName:"tr",align:null},"How to handle existing data. For a list of the possible values, see ",(0,n.yg)("a",{parentName:"td",href:"#supported-write-modes"},"Supported write modes"),"."),(0,n.yg)("td",{parentName:"tr",align:null},(0,n.yg)("inlineCode",{parentName:"td"},"append"))),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Partition Columns"),(0,n.yg)("td",{parentName:"tr",align:null},"List of columns to partition the XLSX files by."),(0,n.yg)("td",{parentName:"tr",align:null},"None")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"Create single named XLSX file"),(0,n.yg)("td",{parentName:"tr",align:null},"Whether to create a single XLSX file."),(0,n.yg)("td",{parentName:"tr",align:null},"false")))),(0,n.yg)("h3",{id:"supported-write-modes"},"Supported write modes"),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Write mode"),(0,n.yg)("th",{parentName:"tr",align:null},"Description"))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"error"),(0,n.yg)("td",{parentName:"tr",align:null},"If the data already exists, throw an exception.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"overwrite"),(0,n.yg)("td",{parentName:"tr",align:null},"If the data already exists, overwrite the data with the contents of the ",(0,n.yg)("inlineCode",{parentName:"td"},"DataFrame"),".")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"append"),(0,n.yg)("td",{parentName:"tr",align:null},"If the data already exists, append the contents of the ",(0,n.yg)("inlineCode",{parentName:"td"},"DataFrame"),".")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"ignore"),(0,n.yg)("td",{parentName:"tr",align:null},"If the data already exists, do nothing with the contents of the ",(0,n.yg)("inlineCode",{parentName:"td"},"DataFrame"),". ",(0,n.yg)("br",null),"This is similar to the ",(0,n.yg)("inlineCode",{parentName:"td"},"CREATE TABLE IF NOT EXISTS")," clause in SQL.")))),(0,n.yg)("h2",{id:"writing-a-single-output-file"},"Writing a single output file"),(0,n.yg)("p",null,"Due to Spark's distributed nature, when you work with text-based files, your output is a directory containing multiple partitioned files."),(0,n.yg)("p",null,"For example, if you write to the following location: ",(0,n.yg)("strong",{parentName:"p"},"dbfs:/FileStore/Users/test/customers.xlsx"),", you see the following in the DBFS:"),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},"A ",(0,n.yg)("strong",{parentName:"li"},"customers.xlsx")," directory."),(0,n.yg)("li",{parentName:"ul"},"Partitions within the ",(0,n.yg)("strong",{parentName:"li"},"customers.xlsx")," directory.")),(0,n.yg)("p",null,"Each partition is a separate valid XLSX file with a segment of the overall output data."),(0,n.yg)("p",null,"If you want the Target gem to output a single file:"),(0,n.yg)("ol",null,(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Add a Repartition gem in ",(0,n.yg)("strong",{parentName:"p"},"Coalesce")," mode with the ",(0,n.yg)("strong",{parentName:"p"},"Partition Count")," set to ",(0,n.yg)("inlineCode",{parentName:"p"},"1"),"."),(0,n.yg)("p",{parentName:"li"},(0,n.yg)("img",{alt:"Coalesce using Repartition",src:a(89510).A,width:"2870",height:"1678"}))),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Connect the Repartition gem between your second-to-last transformation and the ",(0,n.yg)("inlineCode",{parentName:"p"},"Target")," gem."),(0,n.yg)("p",{parentName:"li"},(0,n.yg)("img",{alt:"Attach coalesce before desired target",src:a(25986).A,width:"1906",height:"882"}))),(0,n.yg)("li",{parentName:"ol"},(0,n.yg)("p",{parentName:"li"},"Run your pipeline."),(0,n.yg)("p",{parentName:"li"},"After you run your pipeline, your output is still a directory, but this time it only contains a single output file."))),(0,n.yg)("h2",{id:"example-code"},"Example code"),(0,n.yg)("admonition",{type:"tip"},(0,n.yg)("p",{parentName:"admonition"},"To see the generated source code of your project, ",(0,n.yg)("a",{parentName:"p",href:"/getting-started/tutorials/spark-with-databricks#review-the-code"},"switch to the Code view")," in the project header.")),(0,n.yg)(i.A,{mdxType:"Tabs"},(0,n.yg)(o.A,{value:"py",label:"Python",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-py"},'def Demo_XLSX_Source(spark: SparkSession) -> DataFrame:\n    if Config.fabricName == "dev":\n        return spark.read\\\n            .format("excel")\\\n            .option("header", True)\\\n            .option("dataAddress", "A1")\\\n            .option("inferSchema", True)\\\n            .load("dbfs:/FileStore/Users/scott/plain_number.xlsx")\n    else:\n        raise Exception("No valid dataset present to read fabric")\n')))))}c.isMDXComponent=!0},89510:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/xlsx_tgt_5.5-1f42007802b75662fd2128729bf05f6a.png"},25986:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/xlsx_tgt_6-4fcf34461fd56bcf2dd36f29bb3b223a.png"}}]);