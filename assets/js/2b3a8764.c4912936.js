"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[5279],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return u}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var d=r.createContext({}),s=function(e){var t=r.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=s(e.components);return r.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,d=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(a),u=n,g=c["".concat(d,".").concat(u)]||c[u]||p[u]||l;return a?r.createElement(g,i(i({ref:t},m),{},{components:a})):r.createElement(g,i({ref:t},m))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var s=2;s<l;s++)i[s]=a[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},2360:function(e,t,a){a.d(t,{Z:function(){return i}});var r=a(7294),n=a(6010),l="tabItem_OmH5";function i(e){var t=e.children,a=e.hidden,i=e.className;return r.createElement("div",{role:"tabpanel",className:(0,n.Z)(l,i),hidden:a},t)}},9877:function(e,t,a){a.d(t,{Z:function(){return u}});var r=a(7462),n=a(7294),l=a(2389),i=a(7392),o=a(7094),d=a(2466),s=a(6010),m="tabList_uSqn",p="tabItem_LplD";function c(e){var t,a,l,c=e.lazy,u=e.block,g=e.defaultValue,f=e.values,k=e.groupId,h=e.className,v=n.Children.map(e.children,(function(e){if((0,n.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),N=null!=f?f:v.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,i.l)(N,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var w=null===g?g:null!=(t=null!=g?g:null==(a=v.find((function(e){return e.props.default})))?void 0:a.props.value)?t:null==(l=v[0])?void 0:l.props.value;if(null!==w&&!N.some((function(e){return e.value===w})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+N.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=(0,o.U)(),D=y.tabGroupChoices,x=y.setTabGroupChoices,_=(0,n.useState)(w),F=_[0],T=_[1],S=[],C=(0,d.o5)().blockElementScrollPositionUntilNextRender;if(null!=k){var M=D[k];null!=M&&M!==F&&N.some((function(e){return e.value===M}))&&T(M)}var O=function(e){var t=e.currentTarget,a=S.indexOf(t),r=N[a].value;r!==F&&(C(t),T(r),null!=k&&x(k,r))},E=function(e){var t,a=null;switch(e.key){case"ArrowRight":var r=S.indexOf(e.currentTarget)+1;a=S[r]||S[0];break;case"ArrowLeft":var n=S.indexOf(e.currentTarget)-1;a=S[n]||S[S.length-1]}null==(t=a)||t.focus()};return n.createElement("div",{className:(0,s.Z)("tabs-container",m)},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":u},h)},N.map((function(e){var t=e.value,a=e.label,l=e.attributes;return n.createElement("li",(0,r.Z)({role:"tab",tabIndex:F===t?0:-1,"aria-selected":F===t,key:t,ref:function(e){return S.push(e)},onKeyDown:E,onFocus:O,onClick:O},l,{className:(0,s.Z)("tabs__item",p,null==l?void 0:l.className,{"tabs__item--active":F===t})}),null!=a?a:t)}))),c?(0,n.cloneElement)(v.filter((function(e){return e.props.value===F}))[0],{className:"margin-top--md"}):n.createElement("div",{className:"margin-top--md"},v.map((function(e,t){return(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==F})}))))}function u(e){var t=(0,l.Z)();return n.createElement(c,(0,r.Z)({key:String(t)},e))}},5759:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return m},default:function(){return f},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var r=a(7462),n=a(3366),l=(a(7294),a(3905)),i=a(9877),o=a(2360),d=["components"],s={title:"Delta",sidebar_position:5},m=void 0,p={unversionedId:"low-code-spark/gems/source-target/file/delta",id:"low-code-spark/gems/source-target/file/delta",title:"Delta",description:"Reads data from delta files present at a path and writes delta files to a path based on configuration.",source:"@site/docs/05-low-code-spark/05-gems/01-source-target/01-file/05-delta.md",sourceDirName:"05-low-code-spark/05-gems/01-source-target/01-file",slug:"/low-code-spark/gems/source-target/file/delta",permalink:"/low-code-spark/gems/source-target/file/delta",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Delta",sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"Text",permalink:"/low-code-spark/gems/source-target/file/text"},next:{title:"Json",permalink:"/low-code-spark/gems/source-target/file/json"}},c={},u=[{value:"Source",id:"source",level:2},{value:"Source Parameters",id:"source-parameters",level:3},{value:"Source Example",id:"source-example",level:3},{value:"Spark Code",id:"spark-code",level:3},{value:"Without time travel",id:"without-time-travel",level:4},{value:"Timestamp based time travel",id:"timestamp-based-time-travel",level:4},{value:"Version based time travel",id:"version-based-time-travel",level:4},{value:"Target",id:"target",level:2},{value:"Target Parameters",id:"target-parameters",level:3},{value:"Write modes",id:"write-modes",level:3},{value:"Target Example",id:"target-example",level:3},{value:"Spark Code",id:"spark-code-1",level:3},{value:"Merge write mode with Delta",id:"merge-write-mode-with-delta",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Example",id:"example",level:3},{value:"Spark Code",id:"spark-code-2",level:3},{value:"SCD2 merge write mode with Delta",id:"scd2-merge-write-mode-with-delta",level:2},{value:"Parameters",id:"parameters-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Spark Code",id:"spark-code-3",level:3}],g={toc:u};function f(e){var t=e.components,s=(0,n.Z)(e,d);return(0,l.kt)("wrapper",(0,r.Z)({},g,s,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Reads data from delta files present at a path and writes delta files to a path based on configuration."),(0,l.kt)("h2",{id:"source"},"Source"),(0,l.kt)("p",null,"Reads data from delta files present at a path."),(0,l.kt)("h3",{id:"source-parameters"},"Source Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Location"),(0,l.kt)("td",{parentName:"tr",align:"left"},"File path where delta files are present"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Read Timestamp"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Time travel to a specific timestamp"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Read Version"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Time travel to a specific version of table"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")))),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"For time travel on delta tables:"),(0,l.kt)("ol",{parentName:"div"},(0,l.kt)("li",{parentName:"ol"},"Only one among timestamp and version can be chosen at a time for time travel."),(0,l.kt)("li",{parentName:"ol"},"Timestamp should be between the first commit timestamp and the latest commit timestamp in the table."),(0,l.kt)("li",{parentName:"ol"},"Version needs to be an integer. Its value has to be between min and max version of table.")),(0,l.kt)("p",{parentName:"div"},"By default most recent version of each row is fetched if no time travel option is used."))),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"To read more about delta time travel and its use cases ",(0,l.kt)("a",{parentName:"p",href:"https://databricks.com/blog/2019/02/04/introducing-delta-time-travel-for-large-scale-data-lakes.html"},"click here"),"."))),(0,l.kt)("h3",{id:"source-example"},"Source Example"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Example usage of Delta",src:a(3098).Z,width:"1140",height:"608"})),(0,l.kt)("h3",{id:"spark-code"},"Spark Code"),(0,l.kt)("h4",{id:"without-time-travel"},"Without time travel"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def ReadDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object ReadDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n')))),(0,l.kt)("h4",{id:"timestamp-based-time-travel"},"Timestamp based time travel"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def ReadDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").option("timestampAsOf", "2022-05-05")\\\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object ReadDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").option("timestampAsOf", "2022-05-05")\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n')))),(0,l.kt)("h4",{id:"version-based-time-travel"},"Version based time travel"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def readDelta(spark: SparkSession) -> DataFrame:\n    return spark.read.format("delta").option("versionAsOf", "0")\\\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object readDelta {\n\n  def apply(spark: SparkSession): DataFrame = {\n    spark.read.format("delta").option("versionAsOf", "0")\n        .load("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n')))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"target"},"Target"),(0,l.kt)("p",null,"Writes data in delta format in parquet files based on the configuration."),(0,l.kt)("h3",{id:"target-parameters"},"Target Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Location"),(0,l.kt)("td",{parentName:"tr",align:"left"},"File path where delta files needs to be written"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Write mode"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Write mode for dataframe"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Optimise write"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If true, it optimizes spark partition sizes based on the actual data"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Overwrite table schema"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If true, overwrites the schema of the delta table as per the dataframe"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Merge schema"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If true, then any columns that are present in the DataFrame but not in the target table are automatically added on to the end of the schema as part of a write transaction"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Partition Columns"),(0,l.kt)("td",{parentName:"tr",align:"left"},"List of columns to partition the delta table by"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Overwrite partition predicate"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If specified, then it selectively overwrites only the data that satisfies the given where clause expression."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")))),(0,l.kt)("h3",{id:"write-modes"},"Write modes"),(0,l.kt)("p",null,"Below are different type of write modes which prophecy provided delta format supports."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Write Mode"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"overwrite"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If data already exists, existing data is expected to be overwritten by the contents of the DataFrame.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"append"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If data already exists, contents of the DataFrame are expected to be appended to existing data.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"ignore"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If data already exists, the save operation is expected not to save the contents of the DataFrame and not to change the existing data. This is similar to a CREATE TABLE IF NOT EXISTS in SQL.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"error"),(0,l.kt)("td",{parentName:"tr",align:"left"},"If data already exists, an exception is expected to be thrown.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"merge"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Insert, delete and update data using the delta merge command.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"scd2 merge"),(0,l.kt)("td",{parentName:"tr",align:"left"},"It is a delta merge operation that stores and manages both current and historical data over time.")))),(0,l.kt)("p",null,"Among these write modes overwrite, append, ignore and error works the same way as in case of parquet file writes.\nMerge and SCD2 merge would be explained with examples in the following sections."),(0,l.kt)("h3",{id:"target-example"},"Target Example"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Example usage of Filter",src:a(72).Z,width:"1140",height:"608"})),(0,l.kt)("h3",{id:"spark-code-1"},"Spark Code"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def writeDelta(spark: SparkSession, in0: DataFrame):\n    return in0.write\\\n            .format("delta")\\\n            .option("optimizeWrite", True)\\\n            .option("mergeSchema", True)\\\n            .option("replaceWhere", "order_dt > \'2022-01-01\'")\\\n            .option("overwriteSchema", True)\\\n            .mode("overwrite")\\\n            .partitionBy("order_dt")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object writeDelta {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    in0.write\n        .format("delta")\n        .option("optimizeWrite", True)\n        .option("mergeSchema", True)\n        .option("replaceWhere", "order_dt > \'2022-01-01\'")\n        .option("overwriteSchema", True)\n        .mode("overwrite")\n        .partitionBy("order_dt")\n        .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n  }\n\n}\n\n')))),(0,l.kt)("h2",{id:"merge-write-mode-with-delta"},"Merge write mode with Delta"),(0,l.kt)("p",null,"You can upsert data from a source DataFrame into a target Delta table by using the\nMERGE operation. Delta Lake supports inserts, updates and deletes in MERGE."),(0,l.kt)("p",null,"This operation is also commonly known as upserting (update/insert) or SCD1 merge."),(0,l.kt)("h3",{id:"parameters"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Source alias"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Alias to use for source dataframe"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Target alias"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Alias to use for existing delta table"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Merge Condition"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Condition to merge data from source dataframe to target table, which would be used to perform update, delete, or insert actions as specified."),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Matched Update Action"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Action to choose if update needs to be done or skipped."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Matched Update Condition"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Optional condition for updating row. If a condition is specified, then it must evaluate to true for the row to be updated."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Matched Update Expressions"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Optional expressions for setting the values of columns that need to be updated."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Matched Delete Action"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Action to choose if delete needs to be done or skipped."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Matched Delete Condition"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Optional condition for deleting row. If a condition is specified, then it must evaluate to true for the row to be updated."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Not Matched Action"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Action to choose if inserts needs to be done or skipped."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Not Matched Condition"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Optional condition for inserting row. If a condition is specified, then it must evaluate to true for the row to be updated."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"When Not Matched Expressions"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Optional expressions for setting the values of columns that need to be updated."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")))),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("ol",{parentName:"div"},(0,l.kt)("li",{parentName:"ol"},"At least one action out of update, delete or insert needs to be set. "),(0,l.kt)("li",{parentName:"ol"},"Delete removes the data from the latest version of the Delta table but does not remove it from the physical storage until the old versions are explicitly vacuumed. See ",(0,l.kt)("a",{parentName:"li",href:"https://docs.delta.io/latest/delta-utility.html#-delta-vacuum"},"vaccum")," for details."),(0,l.kt)("li",{parentName:"ol"},"A merge operation can fail if multiple rows of the source dataset match and the merge attempts to update the same rows of the target Delta table. Deduplicate gem can be placed before target if duplicate rows at source are expected.")))),(0,l.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"When possible, provide predicates on the partition columns for a partitioned Delta table as such predicates can significantly speed up the operations."))),(0,l.kt)("h3",{id:"example"},"Example"),(0,l.kt)("p",null,"TODO"),(0,l.kt)("h3",{id:"spark-code-2"},"Spark Code"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def writeDeltaMerge(spark: SparkSession, in0: DataFrame):\n    from delta.tables import DeltaTable, DeltaMergeBuilder\n\n    if DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/orders"):\n        DeltaTable\\\n            .forPath(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/orders")\\\n            .alias("target")\\\n            .merge(in0.alias("source"), (col("source.order_id") == col("target.order_id")))\\\n            .whenMatchedUpdateAll(condition = (col("order_dt") >= date_sub(current_date(), 7)))\\\n            .whenNotMatchedInsertAll()\\\n            .execute()\n    else:\n        in0.write\\\n            .format("delta")\\\n            .mode("overwrite")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object writeDeltaMerge {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    import _root_.io.delta.tables._\n    if (DeltaTable.isDeltaTable(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/orders")) {\n        DeltaTable\n            .forPath(spark, "dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n            .as("target")\n            .merge(in0.as("source"), (col("source.order_id") === col("target.order_id")))\n            .whenMatched(col("order_dt") >= date_sub(current_date(), 7))\n            .updateAll()\n            .whenNotMatched()\n            .insertAll()\n            .execute()\n    }\n    else {\n        in0.write\n            .format("delta")\n            .mode("overwrite")\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n    }\n  }\n\n}\n\n')))),(0,l.kt)("h2",{id:"scd2-merge-write-mode-with-delta"},"SCD2 merge write mode with Delta"),(0,l.kt)("h3",{id:"parameters-1"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Key columns"),(0,l.kt)("td",{parentName:"tr",align:"left"},"List of key columns which would remain constant"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Historic columns"),(0,l.kt)("td",{parentName:"tr",align:"left"},"List of columns which would change over time for which history needs to be maintained"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"From time column"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Time from which a particular row became valid"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"To time column"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Time till which a particular row was valid"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Min/old-value flag"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Column placeholder to store the flag as true for the first entry of a particular key"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Max/latest flag"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Column placeholder to store the flag as true for the last entry of a particular key"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Flag values"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Option to choose the min/max flag to be true/false or 0/1"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True")))),(0,l.kt)("h3",{id:"example-1"},"Example"),(0,l.kt)("p",null,"TODO"),(0,l.kt)("h3",{id:"spark-code-3"},"Spark Code"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def writeDeltaSCD2(spark: SparkSession, in0: DataFrame):\n    from delta.tables import DeltaTable, DeltaMergeBuilder\n\n    if DeltaTable.isDeltaTable(\n        spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n    ):\n        existingTable = DeltaTable.forPath(\n            spark, "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n        )\n        updatesDF = in0.withColumn("minFlag", lit("true")).withColumn(\n            "maxFlag", lit("true")\n        )\n        existingDF = existingTable.toDF()\n        updateColumns = updatesDF.columns\n        stagedUpdatesDF = (\n            updatesDF.join(existingDF, ["customer_id"])\n            .where(\n                (\n                    (existingDF["maxFlag"] == lit("true"))\n                    & (\n                        (\n                            (\n                                existingDF["customer_zip_code"]\n                                != updatesDF["customer_zip_code"]\n                            )\n                            | (\n                                existingDF["customer_city"]\n                                != updatesDF["customer_city"]\n                            )\n                        )\n                        | (existingDF["customer_state"] != updatesDF["customer_state"])\n                    )\n                )\n            )\n            .select(*[updatesDF[val] for val in updateColumns])\n            .withColumn("minFlag", lit("false"))\n            .withColumn("mergeKey", lit(None))\n            .union(updatesDF.withColumn("mergeKey", concat("customer_id")))\n        )\n        existingTable.alias("existingTable").merge(\n            stagedUpdatesDF.alias("staged_updates"),\n            concat(existingDF["customer_id"]) == stagedUpdatesDF["mergeKey"],\n        ).whenMatchedUpdate(\n            condition=(\n                (existingDF["maxFlag"] == lit("true"))\n                & (\n                    (\n                        (\n                            existingDF["customer_zip_code"]\n                            != stagedUpdatesDF["customer_zip_code"]\n                        )\n                        | (\n                            existingDF["customer_city"]\n                            != stagedUpdatesDF["customer_city"]\n                        )\n                    )\n                    | (\n                        existingDF["customer_state"]\n                        != stagedUpdatesDF["customer_state"]\n                    )\n                )\n            ),\n            set={"maxFlag": "false", "end_date": "staged_updates.updated_dt"},\n        )\\\n        .whenNotMatchedInsertAll()\\\n        .execute()\n    else:\n        in0.write\\\n            .format("delta")\\\n            .mode("overwrite")\\\n            .save("dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2")\n\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object writeDeltaSCD2 {\n\n  def apply(spark: SparkSession, in: DataFrame): Unit = {\n    import _root_.io.delta.tables._\n    if (\n      DeltaTable.isDeltaTable(\n        spark,\n        "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n      )\n    ) {\n      val updatesDF = in\n        .withColumn("minFlag", lit("true"))\n        .withColumn("maxFlag", lit("true"))\n      val existingTable: DeltaTable = DeltaTable.forPath(\n        spark,\n        "dbfs:/FileStore/data_engg/delta_demo/silver/customers_scd2"\n      )\n      val existingDF: DataFrame = existingTable.toDF\n      val stagedUpdatesDF = updatesDF\n        .join(existingDF, List("customer_id"))\n        .where(\n          existingDF.col("maxFlag") === lit("true") && List(\n            existingDF.col("customer_zip_code") =!= updatesDF\n              .col("customer_zip_code"),\n            existingDF.col("customer_city") =!= updatesDF\n              .col("customer_city"),\n            existingDF.col("customer_state") =!= updatesDF\n              .col("customer_state")\n          ).reduce((c1, c2) => c1 || c2)\n        )\n        .select(updatesDF.columns.map(x => updatesDF.col(x)): _*)\n        .withColumn("minFlag", lit("false"))\n        .withColumn("mergeKey", lit(null))\n        .union(updatesDF.withColumn("mergeKey", concat(col("customer_id"))))\n      existingTable\n        .as("existingTable")\n        .merge(\n          stagedUpdatesDF.as("staged_updates"),\n          concat(existingDF.col("customer_id")) === stagedUpdatesDF(\n            "mergeKey"\n          )\n        )\n        .whenMatched(\n          existingDF.col("maxFlag") === lit("true") && List(\n            existingDF.col("customer_zip_code") =!= stagedUpdatesDF\n              .col("customer_zip_code"),\n            existingDF.col("customer_city") =!= stagedUpdatesDF\n              .col("customer_city"),\n            existingDF.col("customer_state") =!= stagedUpdatesDF\n              .col("customer_state")\n          ).reduce((c1, c2) => c1 || c2)\n        )\n        .updateExpr(\n          Map("maxFlag" \u2192 "false", "end_date" \u2192 "staged_updates.updated_dt")\n        )\n        .whenNotMatched()\n        .insertAll()\n        .execute()\n    } else {\n      in0.write\n        .format("delta")\n        .mode("overwrite")\n        .save("dbfs:/FileStore/data_engg/delta_demo/silver/orders")\n    }\n\n  }\n\n}\n\n\n')))),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"To checkout more examples on how and when to use merge (SCD1), SCD2, SCD3 write modes using delta with Prophecy ",(0,l.kt)("a",{parentName:"p",href:"https://www.prophecy.io/blogs/prophecy-with-delta"},"click here"),"."))))}f.isMDXComponent=!0},3098:function(e,t,a){t.Z=a.p+"assets/images/delta_source_eg-a9bacfae161d215a8ceeec0330f206b3.gif"},72:function(e,t,a){t.Z=a.p+"assets/images/delta_target_eg-c6f697a3f02a7267907d97f5556e1468.gif"}}]);