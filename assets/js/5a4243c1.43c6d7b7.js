"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[1533],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return c}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(a),c=n,f=m["".concat(s,".").concat(c)]||m[c]||d[c]||l;return a?r.createElement(f,i(i({ref:t},u),{},{components:a})):r.createElement(f,i({ref:t},u))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2360:function(e,t,a){a.d(t,{Z:function(){return i}});var r=a(7294),n=a(6010),l="tabItem_OmH5";function i(e){var t=e.children,a=e.hidden,i=e.className;return r.createElement("div",{role:"tabpanel",className:(0,n.Z)(l,i),hidden:a},t)}},9877:function(e,t,a){a.d(t,{Z:function(){return c}});var r=a(7462),n=a(7294),l=a(2389),i=a(7392),o=a(7094),s=a(2466),p=a(6010),u="tabList_uSqn",d="tabItem_LplD";function m(e){var t,a,l,m=e.lazy,c=e.block,f=e.defaultValue,g=e.values,k=e.groupId,b=e.className,h=n.Children.map(e.children,(function(e){if((0,n.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=g?g:h.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),N=(0,i.l)(v,(function(e,t){return e.value===t.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===f?f:null!=(t=null!=f?f:null==(a=h.find((function(e){return e.props.default})))?void 0:a.props.value)?t:null==(l=h[0])?void 0:l.props.value;if(null!==y&&!v.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=(0,o.U)(),T=w.tabGroupChoices,q=w.setTabGroupChoices,P=(0,n.useState)(y),E=P[0],S=P[1],O=[],C=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=k){var x=T[k];null!=x&&x!==E&&v.some((function(e){return e.value===x}))&&S(x)}var I=function(e){var t=e.currentTarget,a=O.indexOf(t),r=v[a].value;r!==E&&(C(t),S(r),null!=k&&q(k,r))},_=function(e){var t,a=null;switch(e.key){case"ArrowRight":var r=O.indexOf(e.currentTarget)+1;a=O[r]||O[0];break;case"ArrowLeft":var n=O.indexOf(e.currentTarget)-1;a=O[n]||O[O.length-1]}null==(t=a)||t.focus()};return n.createElement("div",{className:(0,p.Z)("tabs-container",u)},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,p.Z)("tabs",{"tabs--block":c},b)},v.map((function(e){var t=e.value,a=e.label,l=e.attributes;return n.createElement("li",(0,r.Z)({role:"tab",tabIndex:E===t?0:-1,"aria-selected":E===t,key:t,ref:function(e){return O.push(e)},onKeyDown:_,onFocus:I,onClick:I},l,{className:(0,p.Z)("tabs__item",d,null==l?void 0:l.className,{"tabs__item--active":E===t})}),null!=a?a:t)}))),m?(0,n.cloneElement)(h.filter((function(e){return e.props.value===E}))[0],{className:"margin-top--md"}):n.createElement("div",{className:"margin-top--md"},h.map((function(e,t){return(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==E})}))))}function c(e){var t=(0,l.Z)();return n.createElement(m,(0,r.Z)({key:String(t)},e))}},1335:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return g},frontMatter:function(){return p},metadata:function(){return d},toc:function(){return c}});var r=a(7462),n=a(3366),l=(a(7294),a(3905)),i=a(9877),o=a(2360),s=["components"],p={title:"Parquet",id:"parquet",description:"Parquet",sidebar_position:2,tags:["gems","file","parquet"]},u=void 0,d={unversionedId:"low-code-spark/gems/source-target/file/parquet",id:"low-code-spark/gems/source-target/file/parquet",title:"Parquet",description:"Parquet",source:"@site/docs/low-code-spark/gems/source-target/file/parquet.md",sourceDirName:"low-code-spark/gems/source-target/file",slug:"/low-code-spark/gems/source-target/file/parquet",permalink:"/low-code-spark/gems/source-target/file/parquet",draft:!1,tags:[{label:"gems",permalink:"/tags/gems"},{label:"file",permalink:"/tags/file"},{label:"parquet",permalink:"/tags/parquet"}],version:"current",sidebarPosition:2,frontMatter:{title:"Parquet",id:"parquet",description:"Parquet",sidebar_position:2,tags:["gems","file","parquet"]},sidebar:"defaultSidebar",previous:{title:"CSV",permalink:"/low-code-spark/gems/source-target/file/csv"},next:{title:"Avro",permalink:"/low-code-spark/gems/source-target/file/avro"}},m={},c=[{value:"Source",id:"source",level:2},{value:"Source Parameters",id:"source-parameters",level:3},{value:"Example",id:"source",level:3},{value:"Generated Code",id:"source-code",level:3},{value:"Target",id:"target",level:2},{value:"Target Parameters",id:"target-parameters",level:3},{value:"Example",id:"target",level:3},{value:"Generated Code",id:"target-code",level:3}],f={toc:c};function g(e){var t=e.components,a=(0,n.Z)(e,s);return(0,l.kt)("wrapper",(0,r.Z)({},f,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Parquet is an open source file format built to handle flat columnar storage data formats.\nParquet operates well with complex data in large volumes.It is known for its both performant data compression\nand its ability to handle a wide variety of encoding types."),(0,l.kt)("p",null,"This gem allows you to read from or write to parquet file."),(0,l.kt)("h2",{id:"source"},"Source"),(0,l.kt)("p",null,"Reads data from parquet files present at a path."),(0,l.kt)("h3",{id:"source-parameters"},"Source Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Required"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Location"),(0,l.kt)("td",{parentName:"tr",align:"left"},"File path where parquet files are present"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Schema"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Schema to be applied on the loaded data. Can be defined/edited as json or inferred using ",(0,l.kt)("inlineCode",{parentName:"td"},"Infer Schema")," button"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Recursive File Lookup"),(0,l.kt)("td",{parentName:"tr",align:"left"},"This is used to recursively load files and it disables partition inferring. Its default value is false. If data source explicitly specifies the partitionSpec when recursiveFileLookup is true, exception will be thrown."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Path Global Filter"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An optional glob pattern to only include files with paths matching the pattern. The syntax follows org.apache.hadoop.fs.GlobFilter. It does not change the behavior of partition discovery."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Modified Before"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An optional timestamp to only include files with modification times occurring before the specified Time. The provided timestamp must be in the following form: YYYY-MM-DDTHH:mm:ss (e.g. 2020-06-01T13:00:00)"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Modified After"),(0,l.kt)("td",{parentName:"tr",align:"left"},"An optional timestamp to only include files with modification times occurring after the specified Time. The provided timestamp must be in the following form: YYYY-MM-DDTHH:mm:ss (e.g. 2020-06-01T13:00:00)"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Merge Schema"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Sets whether we should merge schemas collected from all Parquet part-files. This will override spark.sql.parquet.mergeSchema."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"(value of spark.sql.parquet",(0,l.kt)("br",null),".mergeSchema configuration)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Int96 Rebase mode"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The int96RebaseMode option allows to specify the rebasing mode for INT96 timestamps from the Julian to Proleptic Gregorian calendar. ",(0,l.kt)("br",null),(0,l.kt)("br",null)," Currently supported modes are: ",(0,l.kt)("br",null),(0,l.kt)("br",null),"EXCEPTION: fails in reads of ancient INT96 timestamps that are ambiguous between the two calendars.",(0,l.kt)("br",null),(0,l.kt)("br",null),"CORRECTED: loads INT96 timestamps without rebasing.",(0,l.kt)("br",null),(0,l.kt)("br",null),"LEGACY: performs rebasing of ancient timestamps from the Julian to Proleptic Gregorian calendar."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"(value of spark.sql.parquet",(0,l.kt)("br",null),".int96RebaseModeInRead configuration)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Datetime Rebase mode"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The datetimeRebaseMode option allows to specify the rebasing mode for the values of the DATE, TIMESTAMP_MILLIS, TIMESTAMP_MICROS logical types from the Julian to Proleptic Gregorian calendar.",(0,l.kt)("br",null),"Currently supported modes are:",(0,l.kt)("br",null),(0,l.kt)("br",null),"EXCEPTION: fails in reads of ancient dates/timestamps that are ambiguous between the two calendars.",(0,l.kt)("br",null),(0,l.kt)("br",null),"CORRECTED: loads dates/timestamps without rebasing.",(0,l.kt)("br",null),(0,l.kt)("br",null),"LEGACY: performs rebasing of ancient dates/timestamps from the Julian to Proleptic Gregorian calendar."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"(value of spark.sql.parquet",(0,l.kt)("br",null),".datetimeRebaseModeInRead configuration)")))),(0,l.kt)("h3",{id:"source"},"Example"),(0,l.kt)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"}},(0,l.kt)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"}},(0,l.kt)("iframe",{src:"https://user-images.githubusercontent.com/103921419/175030738-4c53b5c9-73e7-46c7-9fdc-c49048f78572.mp4",title:"Parquet Source",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"}))),(0,l.kt)("h3",{id:"source-code"},"Generated Code"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def read_parquet(spark: SparkSession) -> DataFrame:\n    return spark.read\\\n        .format("parquet")\\\n        .option("mergeSchema", True)\\\n        .load("dbfs:/FileStore/Users/parquet/test.parquet")\n\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object read_parquet {\n\n  def apply(spark: SparkSession): DataFrame =\n    spark.read\n        .format("parquet")\n        .option("mergeSchema", true)\n        .load("dbfs:/FileStore/Users/parquet/test.parquet")\n\n}\n')))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"target"},"Target"),(0,l.kt)("h3",{id:"target-parameters"},"Target Parameters"),(0,l.kt)("p",null,"Write data as parquet files at the specified path."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Parameter"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Required"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Default"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Location"),(0,l.kt)("td",{parentName:"tr",align:"left"},"File path where parquet files are present"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Compression"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Compression codec to use when saving to file. This can be one of the known case-insensitive shorten names (none, uncompressed, snappy, gzip, lzo, brotli, lz4, and zstd). This will override spark.sql.parquet.compression.codec."),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"snappy")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Write Mode"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Write mode for dataframe"),(0,l.kt)("td",{parentName:"tr",align:"left"},"True"),(0,l.kt)("td",{parentName:"tr",align:"left"},"error")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"Partition Columns"),(0,l.kt)("td",{parentName:"tr",align:"left"},"List of columns to partition the parquet files by"),(0,l.kt)("td",{parentName:"tr",align:"left"},"False"),(0,l.kt)("td",{parentName:"tr",align:"left"},"None")))),(0,l.kt)("h3",{id:"target"},"Example"),(0,l.kt)("div",{class:"wistia_responsive_padding",style:{padding:"56.25% 0 0 0",position:"relative"}},(0,l.kt)("div",{class:"wistia_responsive_wrapper",style:{height:"100%",left:0,position:"absolute",top:0,width:"100%"}},(0,l.kt)("iframe",{src:"https://user-images.githubusercontent.com/103921419/175030713-9de9d38a-c145-42e9-8411-baa44a70d0d0.mp4",title:"Parquet Target",allow:"autoplay;fullscreen",allowtransparency:"true",frameborder:"0",scrolling:"no",class:"wistia_embed",name:"wistia_embed",msallowfullscreen:!0,width:"100%",height:"100%"}))),(0,l.kt)("h3",{id:"target-code"},"Generated Code"),(0,l.kt)(i.Z,{mdxType:"Tabs"},(0,l.kt)(o.Z,{value:"py",label:"Python",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},'def write_parquet(spark: SparkSession, in0: DataFrame):\n    in0.write\\\n        .format("parquet")\\\n        .mode("overwrite")\\\n        .save("dbfs:/data/test_output.parquet")\n'))),(0,l.kt)(o.Z,{value:"scala",label:"Scala",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'object write_parquet {\n  def apply(spark: SparkSession, in: DataFrame): Unit =\n    in.write\n        .format("parquet")\n        .mode("overwrite")\n        .save("dbfs:/data/test_output.parquet")\n}\n')))),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"To know more about tweaking parquet related properties in spark config ",(0,l.kt)("a",{parentName:"p",href:"https://spark.apache.org/docs/latest/sql-data-sources-parquet.html"},(0,l.kt)("strong",{parentName:"a"},"click here")),"."))))}g.isMDXComponent=!0}}]);