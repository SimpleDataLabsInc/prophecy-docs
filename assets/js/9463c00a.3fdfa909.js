"use strict";(self.webpackChunkdocs_4=self.webpackChunkdocs_4||[]).push([[43225],{7930:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>d,default:()=>o,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"analysts/scheduling/pipeline-trigger-gem","title":"Pipeline gem","description":"Start pipeline runs from a gem in the canvas","source":"@site/docs/analysts/scheduling/pipeline-trigger-gem.md","sourceDirName":"analysts/scheduling","slug":"/analysts/pipeline-trigger-gem","permalink":"/analysts/pipeline-trigger-gem","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"pipeline","permalink":"/tags/pipeline"},{"inline":true,"label":"trigger","permalink":"/tags/trigger"},{"inline":true,"label":"gem","permalink":"/tags/gem"}],"version":"current","frontMatter":{"title":"Pipeline gem","id":"pipeline-trigger-gem","slug":"/analysts/pipeline-trigger-gem","description":"Start pipeline runs from a gem in the canvas","tags":["pipeline","trigger","gem"]},"sidebar":"mySidebar","previous":{"title":"Schedule trigger types","permalink":"/analysts/triggers"},"next":{"title":"Email alerts","permalink":"/analysts/schedule-email-alerts"}}');var s=n(74848),r=n(28453);const l={title:"Pipeline gem",id:"pipeline-trigger-gem",slug:"/analysts/pipeline-trigger-gem",description:"Start pipeline runs from a gem in the canvas",tags:["pipeline","trigger","gem"]},d=void 0,a={},c=[{value:"Limitations",id:"limitations",level:2},{value:"Input and Output",id:"input-and-output",level:2},{value:"Output schema",id:"output-schema",level:3},{value:"Parameters",id:"parameters",level:2},{value:"Trigger conditions",id:"trigger-conditions",level:3},{value:"Execution behavior",id:"execution-behavior",level:2}];function h(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"The Pipeline gem allows you to run another pipeline from within your current pipeline. It supports conditional triggering, parameter passing, and metadata return for each run. Each Pipeline gem execution can trigger the target pipeline multiple times, with each instance running sequentially. The gem completes only after all triggered runs finish."}),"\n",(0,s.jsxs)(i.p,{children:["This is useful for building orchestrated workflows directly in the visual canvas. You\u2019ll find the gem under the ",(0,s.jsx)(i.strong,{children:"Custom"})," category in the gem drawer."]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:"You can create pipelines solely dedicated to pipeline orchestration using multiple instances of this gem. Clearly label your orchestration pipelines to differentiate them from standard data pipelines."})}),"\n",(0,s.jsx)(i.h2,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsx)(i.p,{children:"The Pipeline gem has the following limitations:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"It can trigger only pipelines within the same project."}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.a,{href:"/analysts/monitoring",children:"Monitoring"})," page doesn't show the parent pipeline that triggered a run using the Pipeline gem."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"input-and-output",children:"Input and Output"}),"\n",(0,s.jsx)(i.p,{children:"The following table describes what the Pipeline gem expects as input and what it will produce as output."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Port"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"in0"})}),(0,s.jsxs)(i.td,{children:["Optional input dataset that may include a ",(0,s.jsx)(i.code,{children:"status"})," column and additional columns.",(0,s.jsx)("br",{}),"Valid statuses include ",(0,s.jsx)(i.code,{children:"success"}),", ",(0,s.jsx)(i.code,{children:"failure"}),", or ",(0,s.jsx)(i.code,{children:"skipped"}),".",(0,s.jsx)("br",{}),"Each row of the input triggers a separate pipeline run per Pipeline gem execution."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.strong,{children:"out"})}),(0,s.jsxs)(i.td,{children:["One output dataset that contains the metadata for each triggered pipeline run. ",(0,s.jsx)("br",{}),"The Pipeline gem returns one row per triggered run."]})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"When no input is connected:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"The Pipeline gem triggers the child pipeline once."}),"\n",(0,s.jsx)(i.li,{children:"The output contains a single row of metadata for that run."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"When an input dataset is connected:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["If a ",(0,s.jsx)(i.code,{children:"status"})," column is present, it is used to evaluate ",(0,s.jsx)(i.a,{href:"#trigger-conditions",children:"trigger conditions"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"If the trigger condition is met, the Pipeline gem triggers the child pipeline once for each input row."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["If a ",(0,s.jsx)(i.code,{children:"status"})," column is ",(0,s.jsx)(i.strong,{children:"not"})," present, the Pipeline gem always triggers the child pipeline once for each input row."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Additional columns can be used to pass parameter values into each run."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"The output contains one row of metadata per input row."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsx)(i.p,{children:"The input dataset can be any dataset (including the output of an upstream Pipeline gem)."})}),"\n",(0,s.jsx)(i.h3,{id:"output-schema",children:"Output schema"}),"\n",(0,s.jsx)(i.p,{children:"Each row in the output table represents a pipeline run triggered from the Pipeline gem. The output schema provides you with the following information for each pipeline run."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Column"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"status"})}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsxs)(i.td,{children:["Final status of the triggered pipeline: ",(0,s.jsx)(i.code,{children:"success"}),", ",(0,s.jsx)(i.code,{children:"failure"}),", or ",(0,s.jsx)(i.code,{children:"skipped"}),"."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"pipelineRunID"})}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsx)(i.td,{children:"Unique ID of the triggered pipeline run."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"startTime"})}),(0,s.jsx)(i.td,{children:"Timestamp"}),(0,s.jsx)(i.td,{children:"Time when the triggered pipeline started."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"endTime"})}),(0,s.jsx)(i.td,{children:"Timestamp"}),(0,s.jsx)(i.td,{children:"Time when the triggered pipeline finished."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"error"})}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsx)(i.td,{children:"Error message, if any."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"logs"})}),(0,s.jsx)(i.td,{children:"String Array"}),(0,s.jsx)(i.td,{children:"Log messages from the triggered pipeline."})]})]})]}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsxs)(i.p,{children:["Pipelines are ",(0,s.jsx)(i.code,{children:"skipped"})," when the input does not meet the trigger condition set in the gem."]})}),"\n",(0,s.jsx)(i.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(i.p,{children:"The Pipeline gem accepts the following parameters."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Parameter"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Pipeline to run"}),(0,s.jsx)(i.td,{children:"Select a pipeline to trigger in the list of pipelines from the same project."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Trigger only if"}),(0,s.jsxs)(i.td,{children:["Choose a ",(0,s.jsx)(i.a,{href:"#trigger-conditions",children:"condition"})," to control when the trigger fires based on the ",(0,s.jsx)(i.code,{children:"status"})," column of the input dataset (if present). If the condition is not met, the Pipeline gem runs, but no pipelines are triggered. The output will show that all pipeline runs were ",(0,s.jsx)(i.code,{children:"skipped"}),"."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Maximum number of pipeline triggers"}),(0,s.jsxs)(i.td,{children:["Set a maximum number of times the child pipeline runs per Pipeline gem execution. Maximum is ",(0,s.jsx)(i.code,{children:"10,000"}),"."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Set pipeline parameters"}),(0,s.jsxs)(i.td,{children:["Set values for the ",(0,s.jsx)(i.a,{href:"/analysts/pipeline-parameters",children:"pipeline parameters"})," defined in the child pipeline. You can specify constants, expressions, or column values for each parameter. If you don\u2019t specify a value, the child pipeline uses its default parameter value."]})]})]})]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:"Use multiple input rows to launch runs of the same pipeline with different sets of parameter values."})}),"\n",(0,s.jsx)(i.h3,{id:"trigger-conditions",children:"Trigger conditions"}),"\n",(0,s.jsx)(i.p,{children:"You can define the pipeline trigger condition by choosing from the following list."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Always run"})," (default): Executes the pipeline unconditionally, regardless of input status (or absence of status)."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"All pipelines succeeded"}),": Executes only when every input row has a ",(0,s.jsx)(i.code,{children:"success"})," status."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"All pipelines failed"}),": Executes only when every input row has a ",(0,s.jsx)(i.code,{children:"failure"})," status."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"All pipelines finished"}),": Executes after all input pipeline runs have completed, regardless of their success or failure."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Any pipeline succeeded"}),": Executes if at least one input row has a ",(0,s.jsx)(i.code,{children:"success"})," status."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Any pipeline failed"}),": Executes if at least one input row has a ",(0,s.jsx)(i.code,{children:"failure"})," status."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"execution-behavior",children:"Execution behavior"}),"\n",(0,s.jsx)(i.p,{children:"Prophecy supports the following execution behaviors when running a Pipeline gem."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Sequential execution"}),": When one Pipeline gem triggers a target pipeline multiple times, pipeline instances run sequentially. The Pipeline gem does not finish running until all instances of the target pipeline finish running."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Sequential triggering"}),": Pipeline gems wait for upstream pipelines to finish running when multiple Pipeline gems are configured sequentially or are configured with sequential ",(0,s.jsx)(i.a,{href:"/analysts/gems/#gem-phase",children:"gem phases"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Parallel triggering"}),": The gem supports parallel execution when separate pipeline branches have the same gem phase."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Recursive triggers"}),": Recursive execution is supported. If a triggered pipeline contains another Pipeline gem, it will execute as expected."]}),"\n"]}),"\n"]})]})}function o(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>d});var t=n(96540);const s={},r=t.createContext(s);function l(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);